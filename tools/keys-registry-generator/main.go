// keys-registry-generator aggregates keybinding information from all TUIs
// in the Grove ecosystem and generates a Go registry file.
//
// Usage: go run ./tools/keys-registry-generator
//
// This tool is called during the build process to generate
// grove/pkg/keys/registry_generated.go containing all TUI keybindings.
package main

import (
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/grovetools/core/pkg/workspace"
	"github.com/grovetools/core/tui/keymap"

	// TUI keymap imports - add new TUIs here
	cx_rules "github.com/grovetools/cx/cmd/rules"
	flow_status "github.com/grovetools/flow/cmd/status_tui"
	hooks_cmd "github.com/grovetools/hooks/cmd"
	nb_cmd "github.com/grovetools/nb/cmd"
	tend_cmd "github.com/grovetools/tend/cmd"
	// Note: nav/cmd/gmux is `package main` and can't be imported.
	// Nav keymaps would need to be refactored to a separate package to be included.
)

// getTUIInfos returns all TUI keymap info from across the ecosystem.
// Add new TUIs here when they implement KeymapInfo().
func getTUIInfos() []keymap.TUIInfo {
	return []keymap.TUIInfo{
		flow_status.KeymapInfo(),
		nb_cmd.BrowserKeymapInfo(),
		cx_rules.KeymapInfo(),
		tend_cmd.RunnerKeymapInfo(),
		hooks_cmd.BrowseKeymapInfo(),
		// TODO: Add nav sessionize once its keymap is refactored to a library package
	}
}

const outputTemplate = `// Code generated by keys-registry-generator. DO NOT EDIT.
// Run 'make keys-registry' to regenerate.

package keys

// TUIRegistry contains keybinding information for all TUIs in the ecosystem.
// This is populated at build time by the keys-registry-generator tool.
var TUIRegistry = []TUIRegistryEntry{
{{- range .TUIs }}
	{
		Name:        "{{ .Name }}",
		Package:     "{{ .Package }}",
		Description: "{{ .Description }}",
		Sections: []SectionEntry{
{{- range .Sections }}
			{
				Name: "{{ .Name }}",
				Bindings: []BindingEntry{
{{- range .Bindings }}
					{Name: "{{ .Name }}", Keys: []string{ {{- range $i, $k := .Keys }}{{ if $i }}, {{ end }}"{{ $k }}"{{ end -}} }, Description: "{{ .Description }}", Enabled: {{ .Enabled }}},
{{- end }}
				},
			},
{{- end }}
		},
	},
{{- end }}
}

// TUIRegistryEntry describes a TUI's keybindings.
type TUIRegistryEntry struct {
	Name        string
	Package     string
	Description string
	Sections    []SectionEntry
}

// SectionEntry describes a keybinding section within a TUI.
type SectionEntry struct {
	Name     string
	Bindings []BindingEntry
}

// BindingEntry describes a single keybinding.
type BindingEntry struct {
	Name        string
	Keys        []string
	Description string
	Enabled     bool
}

// GetTUIByName returns the TUI registry entry for the given name.
func GetTUIByName(name string) *TUIRegistryEntry {
	for i := range TUIRegistry {
		if TUIRegistry[i].Name == name {
			return &TUIRegistry[i]
		}
	}
	return nil
}

// GetTUIsByPackage returns all TUI registry entries for the given package.
func GetTUIsByPackage(pkg string) []TUIRegistryEntry {
	var result []TUIRegistryEntry
	for _, tui := range TUIRegistry {
		if tui.Package == pkg {
			result = append(result, tui)
		}
	}
	return result
}

// AllBindings returns a flat list of all bindings across all TUIs.
func AllBindings() []FlatBinding {
	var result []FlatBinding
	for _, tui := range TUIRegistry {
		for _, section := range tui.Sections {
			for _, binding := range section.Bindings {
				result = append(result, FlatBinding{
					TUI:         tui.Name,
					Package:     tui.Package,
					Section:     section.Name,
					Name:        binding.Name,
					Keys:        binding.Keys,
					Description: binding.Description,
					Enabled:     binding.Enabled,
				})
			}
		}
	}
	return result
}

// FlatBinding is a denormalized binding with TUI context.
type FlatBinding struct {
	TUI         string
	Package     string
	Section     string
	Name        string
	Keys        []string
	Description string
	Enabled     bool
}
`

// Template data types
type bindingData struct {
	Name        string
	Keys        []string
	Description string
	Enabled     bool
}

type sectionData struct {
	Name     string
	Bindings []bindingData
}

type tuiData struct {
	Name        string
	Package     string
	Description string
	Sections    []sectionData
}

type templateData struct {
	TUIs []tuiData
}

func main() {
	log.SetFlags(0)

	// Find ecosystem root
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get working directory: %v", err)
	}

	ecosystemRoot, err := workspace.FindEcosystemRoot(cwd)
	if err != nil {
		log.Fatalf("Failed to find ecosystem root: %v", err)
	}
	log.Printf("Found ecosystem root: %s", ecosystemRoot)

	// Collect TUI info
	tuiInfos := getTUIInfos()

	// Sort by name for consistent output
	sort.Slice(tuiInfos, func(i, j int) bool {
		return tuiInfos[i].Name < tuiInfos[j].Name
	})

	var data templateData
	for _, tui := range tuiInfos {
		td := tuiData{
			Name:        tui.Name,
			Package:     tui.Package,
			Description: escapeString(tui.Description),
		}
		for _, section := range tui.Sections {
			sd := sectionData{Name: section.Name}
			for _, binding := range section.Bindings {
				sd.Bindings = append(sd.Bindings, bindingData{
					Name:        escapeString(binding.Name),
					Keys:        binding.Keys,
					Description: escapeString(binding.Description),
					Enabled:     binding.Enabled,
				})
			}
			td.Sections = append(td.Sections, sd)
		}
		data.TUIs = append(data.TUIs, td)
	}

	// Generate output
	tmpl, err := template.New("registry").Parse(outputTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	outputPath := filepath.Join(ecosystemRoot, "grove", "pkg", "keys", "registry_generated.go")
	f, err := os.Create(outputPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer f.Close()

	if err := tmpl.Execute(f, data); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	log.Printf("Successfully generated keys registry with %d TUIs at %s", len(tuiInfos), outputPath)
}

func escapeString(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	s = strings.ReplaceAll(s, "\n", "\\n")
	return s
}

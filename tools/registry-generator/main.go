package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/grovetools/core/config"
	"github.com/grovetools/core/pkg/workspace"
)

// ToolEntry represents a tool to be added to the registry
type ToolEntry struct {
	RepoName     string
	Alias        string
	Description  string
	Dependencies []string
}

func main() {
	// Get current working directory for output path
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get working directory: %v", err)
	}

	// Find ecosystem root using grove-core's workspace package
	ecosystemRoot, err := workspace.FindEcosystemRoot("")
	if err != nil {
		log.Fatalf("Could not find ecosystem root: %v", err)
	}
	log.Printf("Found ecosystem root: %s", ecosystemRoot)

	// Scan for grove-* directories
	entries, err := os.ReadDir(ecosystemRoot)
	if err != nil {
		log.Fatalf("Failed to read ecosystem directory: %v", err)
	}

	var tools []ToolEntry

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		name := entry.Name()

		projectPath := filepath.Join(ecosystemRoot, name)

		// Find grove config (supports .yml, .yaml, .toml)
		configPath, err := config.FindConfigFile(projectPath)
		if err != nil {
			continue
		}

		// Load and parse config
		cfg, err := config.Load(configPath)
		if err != nil {
			log.Printf("Warning: failed to load %s: %v", configPath, err)
			continue
		}

		// Check if managed (stored in Extensions)
		var managed bool
		if managedRaw, ok := cfg.Extensions["managed"]; ok {
			managed, _ = managedRaw.(bool)
		}

		// Skip if not a managed ecosystem tool
		if !managed {
			continue
		}

		// Get binary info from Extensions
		var binaryName, description string
		var buildAfter []string

		if descRaw, ok := cfg.Extensions["description"]; ok {
			description, _ = descRaw.(string)
		}

		if binaryRaw, ok := cfg.Extensions["binary"]; ok {
			if binaryMap, ok := binaryRaw.(map[string]interface{}); ok {
				binaryName, _ = binaryMap["name"].(string)
			}
		}

		if buildAfterRaw, ok := cfg.Extensions["build_after"]; ok {
			if buildAfterList, ok := buildAfterRaw.([]interface{}); ok {
				for _, item := range buildAfterList {
					if s, ok := item.(string); ok {
						buildAfter = append(buildAfter, s)
					}
				}
			}
		}

		// Skip if no binary defined
		if binaryName == "" {
			continue
		}

		tools = append(tools, ToolEntry{
			RepoName:     cfg.Name,
			Alias:        binaryName,
			Description:  description,
			Dependencies: buildAfter,
		})
	}

	// Sort by repo name for consistent output
	sort.Slice(tools, func(i, j int) bool {
		return tools[i].RepoName < tools[j].RepoName
	})

	// Generate Go file
	var buf bytes.Buffer
	buf.WriteString("// Code generated by tools/registry-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package sdk\n\n")
	buf.WriteString("var toolRegistry = map[string]ToolInfo{\n")

	for _, tool := range tools {
		if len(tool.Dependencies) == 0 {
			buf.WriteString(fmt.Sprintf("\t%q: {Alias: %q, Description: %q},\n",
				tool.RepoName, tool.Alias, tool.Description))
		} else {
			deps := make([]string, len(tool.Dependencies))
			for i, d := range tool.Dependencies {
				deps[i] = fmt.Sprintf("%q", d)
			}
			buf.WriteString(fmt.Sprintf("\t%q: {Alias: %q, Description: %q, Dependencies: []string{%s}},\n",
				tool.RepoName, tool.Alias, tool.Description, strings.Join(deps, ", ")))
		}
	}

	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated code: %v", err)
	}

	// Write to pkg/sdk/registry_generated.go
	outputPath := filepath.Join(cwd, "pkg", "sdk", "registry_generated.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		log.Fatalf("Failed to write registry file: %v", err)
	}

	log.Printf("Successfully generated tool registry with %d tools at %s", len(tools), outputPath)
}

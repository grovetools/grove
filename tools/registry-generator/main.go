package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/grovetools/core/pkg/workspace"
	"gopkg.in/yaml.v3"
)

// GroveConfig represents the relevant parts of grove.yml
type GroveConfig struct {
	Name        string   `yaml:"name"`
	Description string   `yaml:"description"`
	Managed     bool     `yaml:"managed"`
	BuildAfter  []string `yaml:"build_after"`
	Binary      struct {
		Name string `yaml:"name"`
		Path string `yaml:"path"`
	} `yaml:"binary"`
}

// ToolEntry represents a tool to be added to the registry
type ToolEntry struct {
	RepoName     string
	Alias        string
	Description  string
	Dependencies []string
}

func main() {
	// Get current working directory for output path
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Failed to get working directory: %v", err)
	}

	// Find ecosystem root using grove-core's workspace package
	ecosystemRoot, err := workspace.FindEcosystemRoot("")
	if err != nil {
		log.Fatalf("Could not find ecosystem root: %v", err)
	}
	log.Printf("Found ecosystem root: %s", ecosystemRoot)

	// Scan for grove-* directories
	entries, err := os.ReadDir(ecosystemRoot)
	if err != nil {
		log.Fatalf("Failed to read ecosystem directory: %v", err)
	}

	var tools []ToolEntry

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		name := entry.Name()

		projectPath := filepath.Join(ecosystemRoot, name)
		groveYmlPath := filepath.Join(projectPath, "grove.yml")

		// Check if grove.yml exists
		if _, err := os.Stat(groveYmlPath); os.IsNotExist(err) {
			continue
		}

		// Read and parse grove.yml
		data, err := os.ReadFile(groveYmlPath)
		if err != nil {
			log.Printf("Warning: failed to read %s: %v", groveYmlPath, err)
			continue
		}

		var config GroveConfig
		if err := yaml.Unmarshal(data, &config); err != nil {
			log.Printf("Warning: failed to parse %s: %v", groveYmlPath, err)
			continue
		}

		// Skip if not a managed ecosystem tool
		if !config.Managed {
			continue
		}

		// Skip if no binary defined
		if config.Binary.Name == "" {
			continue
		}

		tools = append(tools, ToolEntry{
			RepoName:     config.Name,
			Alias:        config.Binary.Name,
			Description:  config.Description,
			Dependencies: config.BuildAfter,
		})
	}

	// Sort by repo name for consistent output
	sort.Slice(tools, func(i, j int) bool {
		return tools[i].RepoName < tools[j].RepoName
	})

	// Generate Go file
	var buf bytes.Buffer
	buf.WriteString("// Code generated by tools/registry-generator. DO NOT EDIT.\n\n")
	buf.WriteString("package sdk\n\n")
	buf.WriteString("var toolRegistry = map[string]ToolInfo{\n")

	for _, tool := range tools {
		if len(tool.Dependencies) == 0 {
			buf.WriteString(fmt.Sprintf("\t%q: {Alias: %q, Description: %q},\n",
				tool.RepoName, tool.Alias, tool.Description))
		} else {
			deps := make([]string, len(tool.Dependencies))
			for i, d := range tool.Dependencies {
				deps[i] = fmt.Sprintf("%q", d)
			}
			buf.WriteString(fmt.Sprintf("\t%q: {Alias: %q, Description: %q, Dependencies: []string{%s}},\n",
				tool.RepoName, tool.Alias, tool.Description, strings.Join(deps, ", ")))
		}
	}

	buf.WriteString("}\n")

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated code: %v", err)
	}

	// Write to pkg/sdk/registry_generated.go
	outputPath := filepath.Join(cwd, "pkg", "sdk", "registry_generated.go")
	if err := os.WriteFile(outputPath, formatted, 0644); err != nil {
		log.Fatalf("Failed to write registry file: %v", err)
	}

	log.Printf("Successfully generated tool registry with %d tools at %s", len(tools), outputPath)
}

package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/grovetools/core/cli"
	"github.com/grovetools/core/config"
	"github.com/grovetools/core/pkg/paths"
	"github.com/grovetools/core/tui/theme"
	"github.com/grovetools/grove/pkg/keys"
	"github.com/spf13/cobra"
)

// newKeysGenerateCmd creates the 'grove keys generate' command.
func newKeysGenerateCmd() *cobra.Command {
	cmd := cli.NewStandardCommand("generate", "Generate external configurations from grove.toml")

	cmd.Long = `Generate configuration files for external tools based on [keys.*] config sections.

Supported generators:
  tmux    Generate ~/.config/grove/tmux/popups.conf for tmux popup bindings

The generated files can be sourced from the respective tool's configuration.`

	cmd.AddCommand(newKeysGenerateTmuxCmd())

	return cmd
}

// newKeysGenerateTmuxCmd creates the 'grove keys generate tmux' command.
func newKeysGenerateTmuxCmd() *cobra.Command {
	var outputPath string
	var dryRun bool

	cmd := &cobra.Command{
		Use:   "tmux",
		Short: "Generate tmux popup configuration",
		Long: `Generate ~/.cache/grove/tmux/popups.conf from [keys.tmux.popups] config.

The generated file contains tmux 'bind -n' commands for each popup shortcut.
Source this file from your ~/.tmux.conf:

  source-file ~/.cache/grove/tmux/popups.conf`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKeysGenerateTmux(outputPath, dryRun)
		},
	}

	cmd.Flags().StringVarP(&outputPath, "output", "o", "", "Output file path (default: ~/.cache/grove/tmux/popups.conf)")
	cmd.Flags().BoolVarP(&dryRun, "dry-run", "n", false, "Print output without writing to file")

	return cmd
}

func runKeysGenerateTmux(outputPath string, dryRun bool) error {
	cfg, err := config.LoadDefault()
	if err != nil {
		cfg = &config.Config{}
	}

	t := theme.DefaultTheme

	// Load keys extension
	var keysExt keys.KeysExtension
	if cfg != nil {
		_ = cfg.UnmarshalExtension("keys", &keysExt)
	}

	if len(keysExt.Tmux.Popups) == 0 {
		fmt.Println(t.Warning.Render(theme.IconWarning + " No [keys.tmux.popups] defined in grove.toml"))
		fmt.Println(t.Muted.Render("Add popup bindings to your grove.toml:"))
		fmt.Println()
		fmt.Println(t.Code.Render(`[keys.tmux.popups.flow_status]
key = "C-p"
command = "flow tmux status"
style = "run-shell"

[keys.tmux.popups.session_switcher]
key = ["C-f", "M-f"]
command = "nav sz"
style = "popup"
size = { width = "100%", height = "98%" }`))
		return nil
	}

	// Build the configuration content
	var lines []string
	lines = append(lines, "# Grove tmux popup configuration")
	lines = append(lines, "# Generated by: grove keys generate tmux")
	lines = append(lines, fmt.Sprintf("# Last updated: %s", time.Now().Format("2006-01-02 15:04:05")))
	lines = append(lines, "# Source this file in your ~/.tmux.conf:")
	lines = append(lines, "#   source-file ~/.cache/grove/tmux/popups.conf")
	lines = append(lines, "")
	lines = append(lines, "# --- Popup Settings ---")
	lines = append(lines, "set -g popup-border-lines none")
	lines = append(lines, "")

	prefix := keysExt.Tmux.Prefix

	// Determine binding mode:
	// - "<prefix>" = direct prefix table (C-b p → action)
	// - "<prefix> X" = sub-table under prefix (C-b X p → action)
	// - "C-g" etc = sub-table under root key (C-g p → action)
	// - "" = direct root table with modifiers (M-p → action)
	directPrefixTable := prefix == "<prefix>"
	useSubTable := prefix != "" && !directPrefixTable

	if useSubTable {
		escapedPrefix := escapeTmuxKey(prefix)
		lines = append(lines, "# --- Prefix Entry Point ---")
		if strings.HasPrefix(prefix, "<prefix> ") {
			nativeKey := strings.TrimPrefix(prefix, "<prefix> ")
			lines = append(lines, fmt.Sprintf("bind-key %s switch-client -T grove-popups", escapeTmuxKey(nativeKey)))
		} else {
			lines = append(lines, fmt.Sprintf("bind-key -n %s switch-client -T grove-popups", escapedPrefix))
		}

		lines = append(lines, "")
		lines = append(lines, "# --- Built-in Table Commands ---")
		lines = append(lines, "bind-key -T grove-popups Escape switch-client -T root")
		lines = append(lines, "bind-key -T grove-popups C-c switch-client -T root")
		lines = append(lines, "bind-key -T grove-popups q switch-client -T root")

		if !strings.HasPrefix(prefix, "<prefix> ") {
			lines = append(lines, fmt.Sprintf("bind-key -T grove-popups %s send-keys %s", escapedPrefix, escapedPrefix))
		}

		lines = append(lines, "bind-key -T grove-popups ? display-popup -w 100% -h 98% -E \"grove keys popups list | less -R\"")
		lines = append(lines, "")
	} else if directPrefixTable {
		lines = append(lines, "# --- Direct Prefix Table Mode ---")
		lines = append(lines, "# Bindings are added directly to tmux prefix table (e.g., C-b p)")
		lines = append(lines, "")
	}

	// Sort actions for consistent output
	var actions []string
	for action := range keysExt.Tmux.Popups {
		actions = append(actions, action)
	}
	sort.Strings(actions)

	for _, action := range actions {
		popup := keysExt.Tmux.Popups[action]
		keySlice := parseInterfaceToStringSlice(popup.Key)

		cmdStr := popup.Command
		if cmdStr == "" {
			cmdStr = keys.TmuxCommandMap[action]
			if cmdStr == "" {
				cmdStr = action
			}
		}

		style := popup.Style
		if style == "" {
			style = "popup" // Default to popup
		}

		lines = append(lines, fmt.Sprintf("# --- %s (%s) ---", action, style))

		for _, k := range keySlice {
			// Safety Check: Prevent binding single characters to the root table
			if prefix == "" && len(k) == 1 && !strings.Contains(k, "-") {
				fmt.Println(t.Error.Render(fmt.Sprintf("Warning: Refusing to bind single letter '%s' for '%s' in root key table. Please set a prefix or use modifier keys.", k, action)))
				continue
			}

			var bindCmd string
			escapedCmd := escapeTmuxCommand(cmdStr)

			// Determine bind target:
			// - directPrefixTable: no flags (binds to tmux prefix table)
			// - useSubTable: -T grove-popups
			// - otherwise: -n (root table)
			var bindTarget string
			if directPrefixTable {
				bindTarget = "" // No -n or -T, binds to prefix table
			} else if useSubTable {
				bindTarget = "-T grove-popups"
			} else {
				bindTarget = "-n"
			}

			// Format bind target (handle empty case for direct prefix table)
			bindTargetStr := ""
			if bindTarget != "" {
				bindTargetStr = bindTarget + " "
			}

			switch style {
			case "run-shell":
				bindCmd = fmt.Sprintf("bind-key %s%s run-shell \"%s\"", bindTargetStr, k, escapedCmd)
			case "window":
				bindCmd = fmt.Sprintf("bind-key %s%s new-window \"%s\"", bindTargetStr, k, escapedCmd)
			case "popup":
				fallthrough
			default:
				w := "100%"
				h := "98%"
				x := "C"
				y := "C"

				if popup.Size != nil {
					if popup.Size.Width != "" {
						w = popup.Size.Width
					}
					if popup.Size.Height != "" {
						h = popup.Size.Height
					}
				}
				if popup.Position != nil {
					if popup.Position.X != "" {
						x = popup.Position.X
					}
					if popup.Position.Y != "" {
						y = popup.Position.Y
					}
				}

				eFlag := ""
				if popup.ExitOnComplete {
					eFlag = "-E "
				}

				bindCmd = fmt.Sprintf("bind-key %s%s display-popup -w %s -h %s -x %s -y %s %s\"%s\"", bindTargetStr, k, w, h, x, y, eFlag, escapedCmd)
			}
			lines = append(lines, bindCmd)
		}
	}
	lines = append(lines, "")

	content := strings.Join(lines, "\n")

	// Dry run: just print
	if dryRun {
		fmt.Println(t.Header.Render(theme.IconShell + " Generated tmux configuration:"))
		fmt.Println()
		fmt.Println(content)
		return nil
	}

	// Determine output path (use CacheDir instead of ConfigDir)
	if outputPath == "" {
		outputPath = filepath.Join(paths.CacheDir(), "tmux", "popups.conf")
	}

	// Create directory if needed
	outDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", outDir, err)
	}

	// Write the file
	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", outputPath, err)
	}

	// Auto-reload tmux on all running servers
	// List all tmux sockets and reload each one
	socketsDir := "/tmp" // tmux sockets are typically in /tmp or /private/tmp on macOS
	if entries, err := os.ReadDir(socketsDir); err == nil {
		for _, entry := range entries {
			if strings.HasPrefix(entry.Name(), "tmux-") {
				// Found a tmux socket directory, list sockets inside
				socketPath := filepath.Join(socketsDir, entry.Name())
				if sockets, err := os.ReadDir(socketPath); err == nil {
					for _, sock := range sockets {
						serverName := sock.Name()
						_ = exec.Command("tmux", "-L", serverName, "source-file", outputPath).Run()
					}
				}
			}
		}
	}
	// Also try default server (no -L flag)
	_ = exec.Command("tmux", "source-file", outputPath).Run()

	fmt.Printf("%s Generated: %s\n", t.Success.Render(theme.IconSuccess), outputPath)
	fmt.Println()
	fmt.Println(t.Muted.Render("To use, add this to your ~/.tmux.conf:"))
	fmt.Printf("  %s\n", t.Code.Render(fmt.Sprintf("source-file %s", outputPath)))
	fmt.Println()
	fmt.Println(t.Muted.Render("Tmux configuration auto-reloaded."))

	return nil
}

// parseInterfaceToStringSlice converts an interface{} to a string slice.
func parseInterfaceToStringSlice(val interface{}) []string {
	switch v := val.(type) {
	case string:
		return []string{v}
	case []interface{}:
		var res []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				res = append(res, s)
			}
		}
		return res
	case []string:
		return v
	default:
		return nil
	}
}

// escapeTmuxCommand escapes a command for embedding in tmux double-quoted strings.
// This escapes double quotes and dollar signs so shell expansion happens at runtime.
func escapeTmuxCommand(cmd string) string {
	// Escape backslashes first, then quotes, then dollar signs
	result := strings.ReplaceAll(cmd, "\\", "\\\\")
	result = strings.ReplaceAll(result, "\"", "\\\"")
	result = strings.ReplaceAll(result, "$", "\\$")
	return result
}

// escapeTmuxKey escapes a key name for tmux bind-key commands.
// Backslash needs to be doubled in tmux config files.
func escapeTmuxKey(key string) string {
	// Replace any backslash with double backslash for tmux config
	return strings.ReplaceAll(key, "\\", "\\\\")
}

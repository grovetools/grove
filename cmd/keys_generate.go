package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/grovetools/core/cli"
	"github.com/grovetools/core/config"
	"github.com/grovetools/core/pkg/paths"
	"github.com/grovetools/core/tui/theme"
	"github.com/grovetools/grove/pkg/keys"
	"github.com/spf13/cobra"
)

// newKeysGenerateCmd creates the 'grove keys generate' command.
func newKeysGenerateCmd() *cobra.Command {
	cmd := cli.NewStandardCommand("generate", "Generate external configurations from grove.toml")

	cmd.Long = `Generate configuration files for external tools based on [keys.*] config sections.

Supported generators:
  tmux    Generate ~/.config/grove/tmux/popups.conf for tmux popup bindings

The generated files can be sourced from the respective tool's configuration.`

	cmd.AddCommand(newKeysGenerateTmuxCmd())

	return cmd
}

// newKeysGenerateTmuxCmd creates the 'grove keys generate tmux' command.
func newKeysGenerateTmuxCmd() *cobra.Command {
	var outputPath string
	var dryRun bool

	cmd := &cobra.Command{
		Use:   "tmux",
		Short: "Generate tmux popup configuration",
		Long: `Generate ~/.config/grove/tmux/popups.conf from [keys.tmux.popups] config.

The generated file contains tmux 'bind -n' commands for each popup shortcut.
Source this file from your ~/.tmux.conf:

  source-file ~/.config/grove/tmux/popups.conf`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKeysGenerateTmux(outputPath, dryRun)
		},
	}

	cmd.Flags().StringVarP(&outputPath, "output", "o", "", "Output file path (default: ~/.config/grove/tmux/popups.conf)")
	cmd.Flags().BoolVarP(&dryRun, "dry-run", "n", false, "Print output without writing to file")

	return cmd
}

func runKeysGenerateTmux(outputPath string, dryRun bool) error {
	cfg, err := config.LoadDefault()
	if err != nil {
		cfg = &config.Config{}
	}

	t := theme.DefaultTheme

	// Load keys extension
	var keysExt keys.KeysExtension
	if cfg != nil {
		_ = cfg.UnmarshalExtension("keys", &keysExt)
	}

	if len(keysExt.Tmux.Popups) == 0 {
		fmt.Println(t.Warning.Render(theme.IconWarning + " No [keys.tmux.popups] defined in grove.toml"))
		fmt.Println(t.Muted.Render("Add popup bindings to your grove.toml:"))
		fmt.Println()
		fmt.Println(t.Code.Render(`[keys.tmux.popups]
flow_status = "C-p"
nb_tui = "C-n"
session_switcher = ["C-f", "M-f"]`))
		return nil
	}

	// Build the configuration content
	var lines []string
	lines = append(lines, "# Grove tmux popup configuration")
	lines = append(lines, "# Generated by: grove keys generate tmux")
	lines = append(lines, "# Source this file in your ~/.tmux.conf:")
	lines = append(lines, "#   source-file ~/.config/grove/tmux/popups.conf")
	lines = append(lines, "")

	// Sort actions for consistent output
	var actions []string
	for action := range keysExt.Tmux.Popups {
		actions = append(actions, action)
	}
	sort.Strings(actions)

	for _, action := range actions {
		rawKeys := keysExt.Tmux.Popups[action]
		command := keys.TmuxCommandMap[action]
		if command == "" {
			command = action // Fallback to raw action name if unknown
		}

		keySlice := parseInterfaceToStringSlice(rawKeys)
		for _, k := range keySlice {
			// Format: bind -n <key> display-popup -E "<command>"
			// Using display-popup for interactive terminal popups
			lines = append(lines, fmt.Sprintf("bind -n %s display-popup -E \"%s\"", k, command))
		}
	}
	lines = append(lines, "")

	content := strings.Join(lines, "\n")

	// Dry run: just print
	if dryRun {
		fmt.Println(t.Header.Render(theme.IconShell + " Generated tmux configuration:"))
		fmt.Println()
		fmt.Println(content)
		return nil
	}

	// Determine output path
	if outputPath == "" {
		outputPath = filepath.Join(paths.ConfigDir(), "tmux", "popups.conf")
	}

	// Create directory if needed
	outDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", outDir, err)
	}

	// Write the file
	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", outputPath, err)
	}

	fmt.Printf("%s Generated: %s\n", t.Success.Render(theme.IconSuccess), outputPath)
	fmt.Println()
	fmt.Println(t.Muted.Render("To use, add this to your ~/.tmux.conf:"))
	fmt.Printf("  %s\n", t.Code.Render(fmt.Sprintf("source-file %s", outputPath)))
	fmt.Println()
	fmt.Println(t.Muted.Render("Then reload tmux configuration:"))
	fmt.Printf("  %s\n", t.Code.Render("tmux source-file ~/.tmux.conf"))

	return nil
}

// parseInterfaceToStringSlice converts an interface{} to a string slice.
func parseInterfaceToStringSlice(val interface{}) []string {
	switch v := val.(type) {
	case string:
		return []string{v}
	case []interface{}:
		var res []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				res = append(res, s)
			}
		}
		return res
	case []string:
		return v
	default:
		return nil
	}
}

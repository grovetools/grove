package cmd

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/grovetools/core/cli"
	"github.com/grovetools/core/config"
	"github.com/grovetools/core/pkg/paths"
	"github.com/grovetools/core/tui/theme"
	"github.com/grovetools/grove/pkg/keys"
	"github.com/spf13/cobra"
)

// newKeysGenerateCmd creates the 'grove keys generate' command.
func newKeysGenerateCmd() *cobra.Command {
	cmd := cli.NewStandardCommand("generate", "Generate external configurations from grove.toml")

	cmd.Long = `Generate configuration files for external tools based on [keys.*] config sections.

Supported generators:
  tmux    Generate ~/.config/grove/tmux/popups.conf for tmux popup bindings

The generated files can be sourced from the respective tool's configuration.`

	cmd.AddCommand(newKeysGenerateTmuxCmd())

	return cmd
}

// newKeysGenerateTmuxCmd creates the 'grove keys generate tmux' command.
func newKeysGenerateTmuxCmd() *cobra.Command {
	var outputPath string
	var dryRun bool

	cmd := &cobra.Command{
		Use:   "tmux",
		Short: "Generate tmux popup configuration",
		Long: `Generate ~/.cache/grove/tmux/popups.conf from [keys.tmux.popups] config.

The generated file contains tmux 'bind -n' commands for each popup shortcut.
Source this file from your ~/.tmux.conf:

  source-file ~/.cache/grove/tmux/popups.conf`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runKeysGenerateTmux(outputPath, dryRun)
		},
	}

	cmd.Flags().StringVarP(&outputPath, "output", "o", "", "Output file path (default: ~/.cache/grove/tmux/popups.conf)")
	cmd.Flags().BoolVarP(&dryRun, "dry-run", "n", false, "Print output without writing to file")

	return cmd
}

func runKeysGenerateTmux(outputPath string, dryRun bool) error {
	cfg, err := config.LoadDefault()
	if err != nil {
		cfg = &config.Config{}
	}

	t := theme.DefaultTheme

	// Load keys extension
	var keysExt keys.KeysExtension
	if cfg != nil {
		_ = cfg.UnmarshalExtension("keys", &keysExt)
	}

	if len(keysExt.Tmux.Popups) == 0 {
		fmt.Println(t.Warning.Render(theme.IconWarning + " No [keys.tmux.popups] defined in grove.toml"))
		fmt.Println(t.Muted.Render("Add popup bindings to your grove.toml:"))
		fmt.Println()
		fmt.Println(t.Code.Render(`[keys.tmux.popups.flow_status]
key = "C-p"
command = "flow tmux status"
style = "run-shell"

[keys.tmux.popups.session_switcher]
key = ["C-f", "M-f"]
command = "nav sz"
style = "popup"
size = { width = "100%", height = "98%" }`))
		return nil
	}

	// Build the configuration content
	var lines []string
	lines = append(lines, "# Grove tmux popup configuration")
	lines = append(lines, "# Generated by: grove keys generate tmux")
	lines = append(lines, fmt.Sprintf("# Last updated: %s", time.Now().Format("2006-01-02 15:04:05")))
	lines = append(lines, "# Source this file in your ~/.tmux.conf:")
	lines = append(lines, "#   source-file ~/.cache/grove/tmux/popups.conf")
	lines = append(lines, "")
	lines = append(lines, "# --- Popup Settings ---")
	lines = append(lines, "set -g popup-border-lines none")
	lines = append(lines, "")

	// Sort actions for consistent output
	var actions []string
	for action := range keysExt.Tmux.Popups {
		actions = append(actions, action)
	}
	sort.Strings(actions)

	for _, action := range actions {
		popup := keysExt.Tmux.Popups[action]
		keySlice := parseInterfaceToStringSlice(popup.Key)

		cmdStr := popup.Command
		if cmdStr == "" {
			cmdStr = keys.TmuxCommandMap[action]
			if cmdStr == "" {
				cmdStr = action
			}
		}

		style := popup.Style
		if style == "" {
			style = "popup" // Default to popup
		}

		lines = append(lines, fmt.Sprintf("# --- %s (%s) ---", action, style))

		for _, k := range keySlice {
			var bindCmd string
			// Escape the command for tmux: escape quotes and $ signs
			escapedCmd := escapeTmuxCommand(cmdStr)

			switch style {
			case "run-shell":
				bindCmd = fmt.Sprintf("bind-key -n %s run-shell \"%s\"", k, escapedCmd)
			case "window":
				bindCmd = fmt.Sprintf("bind-key -n %s new-window \"%s\"", k, escapedCmd)
			case "popup":
				fallthrough
			default:
				w := "100%"
				h := "98%"
				x := "C"
				y := "C"

				if popup.Size != nil {
					if popup.Size.Width != "" {
						w = popup.Size.Width
					}
					if popup.Size.Height != "" {
						h = popup.Size.Height
					}
				}
				if popup.Position != nil {
					if popup.Position.X != "" {
						x = popup.Position.X
					}
					if popup.Position.Y != "" {
						y = popup.Position.Y
					}
				}

				eFlag := ""
				if popup.ExitOnComplete {
					eFlag = "-E "
				}

				bindCmd = fmt.Sprintf("bind-key -n %s display-popup -w %s -h %s -x %s -y %s %s\"%s\"", k, w, h, x, y, eFlag, escapedCmd)
			}
			lines = append(lines, bindCmd)
		}
	}
	lines = append(lines, "")

	content := strings.Join(lines, "\n")

	// Dry run: just print
	if dryRun {
		fmt.Println(t.Header.Render(theme.IconShell + " Generated tmux configuration:"))
		fmt.Println()
		fmt.Println(content)
		return nil
	}

	// Determine output path (use CacheDir instead of ConfigDir)
	if outputPath == "" {
		outputPath = filepath.Join(paths.CacheDir(), "tmux", "popups.conf")
	}

	// Create directory if needed
	outDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", outDir, err)
	}

	// Write the file
	if err := os.WriteFile(outputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write %s: %w", outputPath, err)
	}

	// Auto-reload tmux if running
	_ = exec.Command("tmux", "source-file", outputPath).Run()

	fmt.Printf("%s Generated: %s\n", t.Success.Render(theme.IconSuccess), outputPath)
	fmt.Println()
	fmt.Println(t.Muted.Render("To use, add this to your ~/.tmux.conf:"))
	fmt.Printf("  %s\n", t.Code.Render(fmt.Sprintf("source-file %s", outputPath)))
	fmt.Println()
	fmt.Println(t.Muted.Render("Tmux configuration auto-reloaded."))

	return nil
}

// parseInterfaceToStringSlice converts an interface{} to a string slice.
func parseInterfaceToStringSlice(val interface{}) []string {
	switch v := val.(type) {
	case string:
		return []string{v}
	case []interface{}:
		var res []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				res = append(res, s)
			}
		}
		return res
	case []string:
		return v
	default:
		return nil
	}
}

// escapeTmuxCommand escapes a command for embedding in tmux double-quoted strings.
// This escapes double quotes and dollar signs so shell expansion happens at runtime.
func escapeTmuxCommand(cmd string) string {
	// Escape backslashes first, then quotes, then dollar signs
	result := strings.ReplaceAll(cmd, "\\", "\\\\")
	result = strings.ReplaceAll(result, "\"", "\\\"")
	result = strings.ReplaceAll(result, "$", "\\$")
	return result
}

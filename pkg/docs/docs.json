{
  "sections": {
    "binary-management": {
      "title": "Binary Management",
      "content": "The `grove` CLI acts as a single entry point for managing and executing a suite of specialized tools. It determines which binary to run based on the current context, enabling users to switch between globally installed releases and local development builds.",
      "subsections": [
        {
          "title": "The Meta-CLI Pattern",
          "content": "Grove uses two primary patterns to provide a unified interface: command delegation and aggregator facades.\n\n### Command Delegation\n\n`grove` is a command delegator. When a command like `grove cx stats` is executed, the `grove` binary finds the appropriate `cx` executable on the system and passes the `stats` argument to it. This allows each tool to be developed and versioned independently while providing a single command structure.\n\n### Aggregator Facades\n\nFor certain high-level tasks, `grove` acts as an aggregator, providing a facade that orchestrates operations across multiple tools or workspaces.\n\n*   **`grove logs`**: Discovers all workspaces in an ecosystem, finds their structured log files, and tails them into a single, aggregated stream.\n*   **`grove llm`**: Provides a consistent set of flags for making requests to different Large Language Models, delegating the request to the correct provider-specific tool (`grove-gemini`, `grove-openai`, etc.) based on the specified model."
        },
        {
          "title": "Binary Resolution Precedence",
          "content": "`grove` determines which version of a tool to run based on a hierarchy of contexts.\n\n1.  **Development Workspace**: If the current directory is within a Git worktree managed by Grove (identified by a `.grove-workspace` file), `grove` will prioritize using binaries built from source within that workspace (e.g., from its local `./bin` directory).\n\n2.  **Global Fallbacks**: If not inside a development workspace, `grove` falls back to the globally managed binaries located in `~/.grove/bin`. This path contains symlinks that are managed by the versioning commands."
        },
        {
          "title": "Version Management Systems",
          "content": "Grove provides two distinct systems for managing the global set of tools that are used as fallbacks when not in a development workspace.\n\n### Released Versions (`grove install` and `grove version`)\n\nThis system manages stable, released versions of tools downloaded from GitHub.\n\n*   `grove install \u003ctool\u003e` downloads a specific, versioned release and stores it in `~/.grove/versions/`.\n*   `grove version use \u003ctool@version\u003e` activates a specific downloaded version by updating a symlink in `~/.grove/bin`.\n\n### Development Versions (`grove dev`)\n\nThis system manages locally-built, development versions from any directory on the filesystem. It is used for testing a development build outside of its specific workspace.\n\n*   `grove dev link \u003cpath\u003e` registers a binary built from a local source tree, making it available to the `dev` system.\n*   `grove dev use \u003ctool\u003e \u003calias\u003e` activates a registered development build, making it the global default for that tool."
        },
        {
          "title": "Explicit PATH Management (`grove activate`)",
          "content": "The `grove activate` command provides a mechanism to bring a development workspace's binaries into the current shell's `PATH`. This makes the binaries directly executable without the `grove` prefix, which is useful for integration with external scripts or IDEs.\n\n**Example Usage:**",
          "code_blocks": [
            "# Activate the current workspace's binaries for this shell session\neval \"$(grove activate)\"\n\n# Deactivate and restore the original PATH\neval \"$(grove activate --reset)\""
          ]
        }
      ]
    },
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a reference for all `grove` commands, organized by functional category.",
      "subsections": [
        {
          "title": "Tool Management",
          "content": "Commands for installing, updating, and listing Grove tools.\n\n### grove install\n\n**Synopsis**: Install Grove tools from GitHub releases.\n\n**Syntax**: `grove install [tool[@version]...]`\n\n**Description**:\nInstalls one or more Grove tools from their GitHub releases. A tool can be specified by its repository name (e.g., `grove-context`) or its alias (`cx`). A specific version can be requested using the `@` syntax (e.g., `cx@v0.1.0`). To install a development build from the `main` branch, use `@nightly`. Using `all` will install all available tools. The command automatically resolves and installs any required dependencies.\n\n**Arguments**:\n-   `[tool[@version]...]` (required): One or more tools to install. Can optionally specify a version.\n\n**Flags**:\n| Flag     | Description                                           |\n| :------- | :---------------------------------------------------- |\n| `--use-gh` | Use the `gh` CLI for downloading, which supports private repositories. |\n\n**Examples**:\n**Related Commands**: `grove update`, `grove self-update`, `grove list`\n\n---\n\n### grove update\n\n**Synopsis**: Update Grove tools.\n\n**Syntax**: `grove update [tools...]`\n\n**Description**:\nUpdates one or more Grove tools by reinstalling their latest versions. This command is an alias for `grove install`. If no tools are specified, it updates the `grove` meta-CLI itself.\n\n**Arguments**:\n-   `[tools...]` (optional): One or more tools to update. If omitted, `grove` itself is updated.\n\n**Flags**:\n| Flag     | Description                                           |\n| :------- | :---------------------------------------------------- |\n| `--use-gh` | Use the `gh` CLI for downloading, which supports private repositories. |\n\n**Examples**:\n**Related Commands**: `grove install`, `grove self-update`\n\n---\n\n### grove self-update\n\n**Synopsis**: Update the `grove` CLI to the latest version.\n\n**Syntax**: `grove self-update`\n\n**Description**:\nThis command is an alias for `grove update grove`. It downloads and replaces the current `grove` binary with the latest available release.\n\n**Flags**:\n| Flag     | Description                                           |\n| :------- | :---------------------------------------------------- |\n| `--use-gh` | Use the `gh` CLI for downloading, which supports private repositories. |\n\n**Examples**:\n**Related Commands**: `grove update`\n\n---\n\n### grove list\n\n**Synopsis**: List available Grove tools.\n\n**Syntax**: `grove list`\n\n**Description**:\nDisplays a table of all available Grove tools, their installation status, currently active version, and the latest available release version from GitHub.\n\n**Flags**:\n| Flag            | Description                                  |\n| :-------------- | :------------------------------------------- |\n| `--check-updates` | Check for latest releases from GitHub. (default `true`) |\n\n**Examples**:\n**Related Commands**: `grove install`\n\n---\n\n### grove alias\n\n**Synopsis**: Manage custom aliases for Grove tools.\n\n**Syntax**: `grove alias [subcommand]`\n\n**Description**:\nManages custom aliases for Grove tools, which can resolve PATH conflicts or suit personal preferences. When an alias is set, the tool's binary/symlink in `~/.grove/bin` is renamed.\n\n**Subcommands**:\n-   `set \u003ctool\u003e \u003cnew-alias\u003e`: Sets a custom alias for a tool.\n-   `unset \u003ctool\u003e`: Removes a custom alias, reverting to the default.\n\n**Examples**:",
          "code_blocks": [
            "# Install the latest version of grove-context\ngrove install cx\n\n# Install a specific version of grove-context\ngrove install grove-context@v0.1.0\n\n# Install a nightly build of grove-flow\ngrove install flow@nightly\n\n# Install multiple tools\ngrove install cx nb flow\n\n# Install all available tools\ngrove install all\n\n# Install all nightly builds\ngrove install all@nightly",
            "# Update the grove CLI itself\ngrove update\n\n# Update specific tools\ngrove update context flow\n\n# Update all installed tools\ngrove update all",
            "# Update the grove CLI to its latest version\ngrove self-update",
            "# List all tools and their status\ngrove list",
            "# List all custom and default aliases\ngrove alias\n\n# Set a new alias for grove-context\ngrove alias set grove-context ctx\n\n# Revert to the default alias\ngrove alias unset grove-context"
          ]
        },
        {
          "title": "Version Management",
          "content": "Commands for managing different installed versions of tools.\n\n### grove version\n\n**Synopsis**: Manage Grove tool versions.\n\n**Syntax**: `grove version [subcommand]`\n\n**Description**:\nWhen run without subcommands, it prints version information for the `grove` meta-CLI itself. It also serves as the parent command for listing, switching, and uninstalling specific tool versions.\n\n**Flags**:\n| Flag     | Description                             |\n| :------- | :-------------------------------------- |\n| `--json` | Output version information in JSON format. |\n\n**Subcommands**:\n-   `list`: List all locally installed versions of all tools.\n-   `use \u003ctool@version\u003e`: Switch a tool to a specific installed version.\n-   `uninstall \u003cversion\u003e`: Uninstall a specific version of all tools it contains.\n\n**Examples**:",
          "code_blocks": [
            "# Show version of the grove meta-CLI\ngrove version\n\n# List all installed tool versions\ngrove version list\n\n# Switch grove-context to an installed version\ngrove version use cx@v0.1.0\n\n# Uninstall a specific version\ngrove version uninstall v0.1.0"
          ]
        },
        {
          "title": "Local Development",
          "content": "Commands for managing local, source-built development binaries. These commands allow you to use versions of tools that are not from an official release, which is useful for development and testing.\n\n### grove dev\n\n**Synopsis**: Manage local development binaries.\n\n**Syntax**: `grove dev [subcommand]`\n\n**Description**:\nThe parent command for a suite of tools that manage local development binaries built from source. This allows for switching between different versions of Grove tools built from different Git worktrees. This system is distinct from `grove version`, which manages official releases.\n\n**Subcommands**:\n-   `link`: Register binaries from a local worktree.\n-   `unlink`: Remove a registered local development version.\n-   `use`: Switch to a specific locally-linked version of a binary.\n-   `list`: List registered local development versions.\n-   `list-bins`: List all binaries managed by local development links.\n-   `current`: Show currently active local development versions.\n-   `prune`: Remove registered versions whose binaries no longer exist.\n-   `reset`: Reset all binaries to their main/released versions.\n-   `cwd`: Globally activate binaries from the current directory.\n-   `tui`: Launch an interactive tool version manager.\n-   `workspace`: Display information about the current workspace context.\n\n---\n\n### grove activate\n\n**Synopsis**: Generate shell commands to activate workspace binaries.\n\n**Syntax**: `grove activate`\n\n**Description**:\nOutputs shell commands that, when evaluated, will modify the current shell's `PATH` to prioritize binaries from the current workspace. This is useful for making workspace-specific tools directly available in the shell. The command auto-detects the shell type (bash, zsh, fish).\n\n**Flags**:\n| Flag      | Description                                                    |\n| :-------- | :------------------------------------------------------------- |\n| `--reset` | Generate commands to reset the `PATH` to its original state.         |\n| `--shell` | Specify shell type (`bash`, `zsh`, `fish`). Auto-detected if omitted. |\n\n**Examples**:",
          "code_blocks": [
            "# Activate workspace binaries in the current shell\neval \"$(grove activate)\"\n\n# Reset PATH to its original state\neval \"$(grove activate --reset)\""
          ]
        },
        {
          "title": "Workspace \u0026 Ecosystem Management",
          "content": "Commands for creating, managing, and getting insights into a monorepo containing multiple Grove workspaces.\n\n### grove workspace (ws)\n\n**Synopsis**: Workspace operations across the monorepo.\n\n**Syntax**: `grove workspace [subcommand]`\n\n**Description**:\nParent command for viewing aggregated information and executing operations across all discovered workspaces in an ecosystem.\n\n**Subcommands**:\n-   `init`: Initialize a new Grove ecosystem.\n-   `create`: Create a new development workspace worktree.\n-   `open`: Open a tmux session for a workspace.\n-   `remove`: Remove a development workspace worktree.\n-   `list`: List workspaces and their Git worktrees.\n-   `status`: Show aggregated status for all workspaces.\n-   `worktrees`: Show Git worktrees for all workspaces.\n-   `issues`: Show notebook issues for all workspaces.\n-   `current`: Show notebook current notes for all workspaces.\n-   `plans`: Show flow plans for all workspaces.\n-   `chats`: Show flow chats for all workspaces.\n-   `git-hooks`: Manage Git hooks across all workspaces.\n-   `secrets`: Manage GitHub repository secrets.\n-   `manage`: Interactively manage notes (alias for `nb manage`).\n\n---\n\n### grove add-repo\n\n**Synopsis**: Create a new Grove repository with standard structure.\n\n**Syntax**: `grove add-repo \u003crepo-name\u003e`\n\n**Description**:\nCreates a new Grove repository with idiomatic structure. By default, it creates a standalone repository. Use the `--ecosystem` flag to add it as a submodule to an existing Grove ecosystem.\n\n**Arguments**:\n-   `\u003crepo-name\u003e` (required): The name of the new repository.\n\n**Flags**:\n| Flag                | Alias | Description                                                                |\n| :------------------ | :---- | :------------------------------------------------------------------------- |\n| `--alias`           | `-a`  | Binary alias (e.g., `cx` for `grove-context`).                               |\n| `--description`     | `-d`  | Repository description.                                                    |\n| `--skip-github`     |       | Skip GitHub repository creation.                                           |\n| `--dry-run`         |       | Preview operations without executing them.                                 |\n| `--stage-ecosystem` |       | Stage ecosystem changes in Git after adding the repo.                      |\n| `--template`        |       | Template to use (`go`, `maturin`, `react-ts`, or a GitHub repo `owner/repo`). |\n| `--ecosystem`       |       | Add repository to an existing Grove ecosystem as a submodule.                |\n| `--public`          |       | Create a public repository and skip private configuration.                 |\n\n**Examples**:\n**Related Commands**: `grove workspace init`\n\n---\n\n### grove deps\n\n**Synopsis**: Manage dependencies across the Grove ecosystem.\n\n**Syntax**: `grove deps [subcommand]`\n\n**Description**:\nProvides tools for managing Go module dependencies across all Grove submodules within an ecosystem.\n\n**Subcommands**:\n-   `bump \u003cmodule[@version]\u003e`: Bumps a specific dependency version across all submodules.\n-   `sync`: Updates all internal Grove dependencies to their latest versions.\n-   `tree [repo]`: Displays a dependency tree visualization.\n\n**Examples**:\n\n---\n\n### grove run\n\n**Synopsis**: Run a command in all workspaces.\n\n**Syntax**: `grove run \u003ccommand\u003e [args...]`\n\n**Description**:\nExecutes a given command in each discovered workspace directory.\n\n**Arguments**:\n-   `\u003ccommand\u003e [args...]` (required): The command and its arguments to execute.\n\n**Flags**:\n| Flag       | Alias | Description                                     |\n| :--------- | :---- | :---------------------------------------------- |\n| `--filter` | `-f`  | Filter workspaces by a glob pattern.            |\n| `--exclude`|       | Comma-separated list of workspaces to exclude.  |\n| `--json`   |       | Aggregate and output results in JSON format.    |\n\n**Examples**:\n\n---\n\n### grove docs\n\n**Synopsis**: Manage documentation across the ecosystem.\n\n**Syntax**: `grove docs [subcommand]`\n\n**Description**:\nProvides tools for managing documentation across all discovered workspaces.\n\n**Subcommands**:\n-   `generate`: Runs `docgen generate` in each discovered workspace to update all documentation in a single step. Accepts a `--commit` flag to commit changes.\n\n**Examples**:",
          "code_blocks": [
            "# Create a standalone Go repository\ngrove add-repo my-tool --alias mt --description \"My new tool\"\n\n# Create a Python/Rust repository and add it to the current ecosystem\ngrove add-repo my-lib --template maturin --alias ml --ecosystem",
            "# Update all internal dependencies to their latest versions and commit\ngrove deps sync --commit\n\n# Bump a specific core library to a specific version\ngrove deps bump github.com/mattsolo1/grove-core@v0.3.0\n\n# View the entire dependency graph\ngrove deps tree",
            "# Run git status in all workspaces\ngrove run git status\n\n# Run tests in all workspaces matching a pattern\ngrove run --filter \"grove-*\" make test",
            "# Generate documentation for all workspaces and commit the changes\ngrove docs generate --commit"
          ]
        },
        {
          "title": "Release Orchestration",
          "content": "Commands for managing a stateful, multi-step release workflow across the entire ecosystem.\n\n### grove release\n\n**Synopsis**: Manage releases for the Grove ecosystem.\n\n**Syntax**: `grove release [subcommand]`\n\n**Description**:\nThe parent command for a stateful release workflow. The typical workflow is `plan` -\u003e `tui` -\u003e `apply`.\n\n**Subcommands**:\n-   `plan`: Generates a release plan by analyzing all repositories for changes.\n-   `tui` (or `review`): Launches an interactive TUI to review, modify, and approve the plan.\n-   `apply`: Executes the approved release plan.\n-   `clear-plan`: Clears the current release plan to start over.\n-   `undo-tag`: Removes tags created during a release, locally and optionally from remote.\n-   `rollback`: Rolls back commits in repositories from the release plan to recover from a failed release.\n\n**Examples**:\n\n---\n\n### grove changelog\n\n**Synopsis**: Generate a changelog for a repository.\n\n**Syntax**: `grove changelog \u003crepo-path\u003e`\n\n**Description**:\nGenerates a changelog entry for a repository based on its Git history since the last tag and prepends it to `CHANGELOG.md`. By default, it uses conventional commits. With the `--llm` flag, it uses an LLM to generate a more descriptive summary.\n\n**Arguments**:\n-   `\u003crepo-path\u003e` (required): The path to the repository.\n\n**Flags**:\n| Flag      | Description                               |\n| :-------- | :---------------------------------------- |\n| `--version` | The new version for the changelog header. |\n| `--llm`   | Generate the changelog using an LLM.    |\n\n**Examples**:",
          "code_blocks": [
            "# 1. Generate a release plan\ngrove release plan\n\n# 2. Interactively review and approve the plan\ngrove release tui\n\n# 3. Execute the approved plan\ngrove release apply\n\n# (If something goes wrong) Undo the tags from the last plan\ngrove release undo-tag --from-plan --remote",
            "# Generate changelog from conventional commits for the current directory\ngrove changelog . --version v1.2.3\n\n# Generate changelog using an LLM\ngrove changelog . --version v1.2.3 --llm"
          ]
        },
        {
          "title": "Git Integration",
          "content": "Commands for running Git operations across workspaces.\n\n### grove git\n\n**Synopsis**: Git operations across workspaces.\n\n**Syntax**: `grove git [git-command-args...]`\n\n**Description**:\nA convenience wrapper that executes a `git` command across all discovered workspaces. This is an alias for `grove run git [args...]`.\n\n**Examples**:\n**Related Commands**: `grove workspace status`\n\n---\n\n### grove git-hooks\n\n**Synopsis**: Manage Git hooks for Grove repositories.\n\n**Syntax**: `grove git-hooks [subcommand]`\n\n**Description**:\nInstalls or uninstalls Git hooks that enforce conventional commit message formats in the current repository.\n\n**Subcommands**:\n-   `install`: Installs the `commit-msg` hook.\n-   `uninstall`: Removes the Grove-managed `commit-msg` hook.\n\n**Examples**:\n**Related Commands**: `grove workspace git-hooks`",
          "code_blocks": [
            "# Fetch from origin in all workspaces\ngrove git fetch\n\n# See a condensed status for all workspaces\ngrove ws status",
            "# Install conventional commit hooks in the current git repository\ngrove git-hooks install"
          ]
        },
        {
          "title": "Utility Commands",
          "content": "General-purpose helper commands.\n\n### grove llm\n\n**Synopsis**: Unified interface for LLM providers.\n\n**Syntax**: `grove llm [subcommand]`\n\n**Description**:\nProvides a single, consistent entry point for all LLM interactions, intelligently delegating to the appropriate provider-specific tool (e.g., `gemapi`, `grove-openai`) based on the model name.\n\n**Subcommands**:\n-   `request [prompt...]`: Makes a request to an LLM provider. This command accepts a superset of flags from the underlying tools. Use `grove llm request --help` for a full list of options.\n\n**Examples**:\n\n---\n\n### grove logs\n\n**Synopsis**: Tail logs from workspaces.\n\n**Syntax**: `grove logs [workspace-filter...]`\n\n**Description**:\nProvides a real-time, color-coded view of structured logs from workspaces. By default, it launches an interactive TUI.\n\n**Arguments**:\n-   `[workspace-filter...]` (optional): Filter to show logs only from workspaces whose names contain the filter string.\n\n**Flags**:\n| Flag        | Alias | Description                               | Default |\n| :---------- | :---- | :---------------------------------------- | :------ |\n| `--ecosystem` |       | Show logs from all workspaces.            | `false` |\n| `--follow`  | `-f`  | Continuously tail logs.                   | `true`  |\n| `--lines`   | `-n`  | Number of historical lines to show.       | `10`    |\n| `--tui`     | `-i`  | Launch interactive TUI mode.              | `true` if tty |\n| `--verbose` | `-v`  | Increase verbosity (use `-v`, `-vv`, `-vvv`). |         |\n\n**Examples**:",
          "code_blocks": [
            "# Make a request using the default model configured in grove.yml\ngrove llm request \"Explain the reconciler pattern in grove-meta\"\n\n# Make a request to a specific GPT model\ngrove llm request --model gpt-4o-mini \"Summarize the changes in the last commit\"",
            "# Launch the interactive TUI for logs from all workspaces\ngrove logs --ecosystem\n\n# Tail logs from 'grove-context' and 'grove-flow' in the terminal\ngrove logs context flow --tui=false"
          ]
        }
      ]
    },
    "configuration": {
      "title": "Configuration",
      "content": "Grove uses a layered configuration system with YAML files. This allows for setting defaults at a high level and overriding them for specific projects.",
      "subsections": [
        {
          "title": "Configuration Files and Locations",
          "content": "Settings are managed through a hierarchy of files.\n\n| File Location                | Purpose                                                                 | Managed By                         |\n| :--------------------------- | :---------------------------------------------------------------------- | :--------------------------------- |\n| `[ECOSYSTEM_ROOT]/grove.yml` | Defines the ecosystem, its workspaces, and global defaults for tools.   | User (manual edit)                 |\n| `[WORKSPACE_DIR]/grove.yml`  | Defines a workspace and can override ecosystem-level settings.          | User (manual edit)                 |\n| `~/.grove/active_versions.json` | Tracks the active released version for each installed tool.             | `grove install`, `grove version use` |\n| `~/.grove/devlinks.json`     | Registers local development binaries from worktrees.                    | `grove dev link`, `grove dev use`    |\n| `~/.grove/aliases.json`      | Stores user-defined custom aliases for tools.                           | `grove alias set`, `grove alias unset` |"
        },
        {
          "title": "The `grove.yml` File",
          "content": "The `grove.yml` file is the primary configuration file for both ecosystems and individual workspaces.\n\n### Ecosystem `grove.yml`\n\nWhen placed at the root of a monorepo, this file defines the ecosystem.\n\n**Key Fields:**\n\n| Key           | Type       | Description                                                                    |\n| :------------ | :--------- | :----------------------------------------------------------------------------- |\n| `name`        | `string`   | The name of the ecosystem.                                                     |\n| `description` | `string`   | A brief description of the ecosystem's purpose.                                |\n| `workspaces`  | `[]string` | An array of glob patterns used to discover workspaces (e.g., `[\"*\"]`). |\n\n**Example Ecosystem `grove.yml`:**\n\n\n### Workspace `grove.yml`\n\nWhen placed within a workspace directory, this file defines the properties of that project.\n\n**Key Fields:**\n\n| Key           | Type     | Description                                                               |\n| :------------ | :------- | :------------------------------------------------------------------------ |\n| `name`        | `string` | The canonical name of the workspace (e.g., `grove-context`).              |\n| `description` | `string` | A brief description of the workspace's purpose.                           |\n| `type`        | `string` | The project type, used by the release engine (e.g., `go`, `maturin`). |\n| `binary`      | `object` | Contains information about the binary produced by this workspace.         |\n| `logging`     | `object` | Configures structured logging for the tool.                               |\n\n**Example Workspace `grove.yml`:**\n\n\n### Tool-Specific Configuration\n\nTools can define their own configuration blocks within `grove.yml`, identified by a key matching the tool's name (e.g., `flow`, `llm`).\n\n**Example `flow` configuration block:**\n\n\n### Local Override Configuration\n\nFor configuration values that should not be committed to version control (such as API keys, local paths, or developer-specific settings), Grove supports local override files.\n\n**Supported Override Files:**\n\n- `grove.override.yml` / `grove.override.yaml` - Local, uncommitted configuration\n- `.grove.override.yml` / `.grove.override.yaml` - Hidden variant (prefix with `.` to hide from `ls`)\n\n**Best Practice:**\n\nAdd override files to your project's `.gitignore` to prevent accidental commits of sensitive information:\n\n\n**Example Use Case:**\n\n**`grove.yml` (committed to version control):**\n\n**`grove.override.yml` (git-ignored, local only):**\n\nIn this example:\n- The base configuration is in `grove.yml` (committed)\n- Local overrides in `grove.override.yml` provide the API key and override the model\n- The merged configuration will use the API key and model from `grove.override.yml`\n- The `grove.override.yml` file is never committed to version control",
          "code_blocks": [
            "# ./grove.yml\nname: grove-ecosystem\ndescription: A collection of AI-assisted development tools.\nworkspaces:\n  - \"*\" # Discover all subdirectories with a grove.yml as workspaces\n\n# Global tool-specific settings can be defined here\nflow:\n  oneshot_model: gemini-2.5-pro",
            "# ./grove-context/grove.yml\nname: grove-context\ndescription: Rule-based tool for managing file-based LLM context.\ntype: go\n\nbinary:\n  name: cx\n  path: ./bin/cx\n\nlogging:\n  file:\n    enabled: true\n    format: json\n\n# Workspace-specific overrides for tool configurations\nflow:\n  chat_directory: ./dev-chats",
            "# ./.grove/config.yml or ./grove.yml\nflow:\n  plans_directory: ./plans\n  chat_directory: ./chats\n  oneshot_model: gemini-2.5-pro\n  target_agent_container: grove-agent-ide\n  summarize_on_complete: true",
            "# .gitignore\n\n# Grove local configuration overrides\ngrove.override.yml\ngrove.override.yaml\n.grove.override.yml\n.grove.override.yaml",
            "name: my-project\ndescription: My awesome project\n\ngemini:\n  model: gemini-1.5-flash-latest",
            "# Local overrides - API keys and developer-specific settings\ngemini:\n  api_key: gsk_YourSecretApiKeyHere\n  model: gemini-1.5-pro-latest\n\nflow:\n  chat_directory: /Users/me/personal-chats"
          ]
        },
        {
          "title": "User-Level Configuration (`~/.grove/`)",
          "content": "The `~/.grove` directory stores user-specific configuration and state. These files are generally managed by `grove` commands.\n\n-   **`active_versions.json`**: A JSON file mapping each tool's repository name to its active released version tag (e.g., `\"grove-context\": \"v0.5.1\"`). Managed by `grove version use`.\n-   **`devlinks.json`**: A registry of locally-built binaries linked using `grove dev link`. It tracks binary paths and the active alias for each tool.\n-   **`aliases.json`**: A map of repository names to custom aliases, which override default tool aliases. Managed by `grove alias`."
        },
        {
          "title": "Configuration Precedence",
          "content": "Grove resolves settings in a specific order. A setting from a higher level overrides one from a lower level.\n\n1.  **Command-Line Flags** (Highest Priority)\n2.  **Environment Variables**\n3.  **Local Override Files** (`grove.override.yml`, `.grove.override.yml`)\n4.  **Workspace `grove.yml`**\n5.  **Ecosystem `grove.yml`** (auto-detected when in a workspace)\n6.  **Global Configuration** (`~/.config/grove/grove.yml`)\n7.  **Application Defaults** (Lowest Priority)\n\n### Configuration File Hierarchy\n\nThe configuration loading process follows this hierarchy:\n\n1. **Global config** (`~/.config/grove/grove.yml`) - loaded first as base\n2. **Ecosystem config** (`grove.yml` with `workspaces` field) - merged if current config is a workspace\n3. **Workspace/Project config** (`grove.yml`) - the config found in current directory or parents\n4. **Local override files** (`grove.override.yml` or `.grove.override.yml`) - merged last with highest priority\n\n**Ecosystem Auto-Detection:**\n- When loading a workspace config (without `workspaces` field), Grove automatically searches upward for an ecosystem config\n- An ecosystem config is identified by the presence of a `workspaces` field\n- This allows ecosystem-wide defaults to be inherited by all workspaces\n\n**Example Hierarchy:**",
          "code_blocks": [
            "~/.config/grove/grove.yml          # Global defaults\n/project/grove.yml                 # Ecosystem config (has workspaces: [...])\n/project/my-workspace/grove.yml    # Workspace config\n/project/my-workspace/grove.override.yml  # Local overrides"
          ]
        },
        {
          "title": "Environment Variables",
          "content": "Grove uses several environment variables to control its behavior.\n\n| Variable               | Description                                                                                   |\n| :--------------------- | :-------------------------------------------------------------------------------------------- |\n| `GROVE_PAT`            | A GitHub Personal Access Token used by `grove add-repo` and `release` for private repository operations. |\n| `GROVE_DEBUG`          | If set to `true`, enables verbose debug logging for all Grove tools.                          |\n| `GROVE_WORKSPACE_ROOT` | (Set by `grove activate`) The absolute path to the active development workspace root.           |\n| `GROVE_ORIGINAL_PATH`  | (Set by `grove activate`) A backup of the original `PATH` variable, used to deactivate a workspace.  |\n| `EDITOR`               | The user's preferred command-line editor, used by commands like `cx edit`. Defaults to `vim`. |"
        }
      ]
    },
    "ecosystems": {
      "title": "Ecosystems",
      "content": "The `grove` CLI includes commands for managing interdependent projects within a single monorepo, which is termed an \"Ecosystem\". These commands provide aggregated views and a dependency-aware release process.",
      "subsections": [
        {
          "title": "Defining an Ecosystem",
          "content": "Grove operates on two organizational units: the Workspace and the Ecosystem.\n\n*   A **Workspace** is a directory that represents a single project and is identified by the presence of a `grove.yml` configuration file.\n*   An **Ecosystem** is a top-level directory containing multiple workspaces. It is defined by a root `grove.yml` file that includes a `workspaces` field with glob patterns (e.g., `workspaces: [\"*\"]`) for locating the individual project directories. The discovery logic is implemented in `pkg/workspace/discover.go`."
        },
        {
          "title": "Aggregated Views",
          "content": "Several `grove workspace` (aliased as `ws`) commands aggregate information from every workspace in an ecosystem.\n\n*   **`grove ws status`**: Outputs a table summarizing the Git status, CI status for the main branch, and the status of open pull requests for each workspace. This is implemented in `cmd/workspace_status.go`.\n*   **`grove ws plans`**, **`ws chats`**, and **`ws current`**: These commands gather and display data from other Grove tools. They list all active `grove-flow` plans, all ongoing `grove-flow` chats, or all \"current\" `grove-notebook` notes in a single view. The aggregation mechanism is defined in `pkg/aggregator/aggregator.go`."
        },
        {
          "title": "The Release Engine",
          "content": "The `grove release` command orchestrates releases across all workspaces in an ecosystem through a structured, multi-step process.\n\n*   **Dependency Graph**: Before a release, `grove` builds a dependency graph by parsing project files (e.g., `go.mod`, `pyproject.toml`) in each workspace. This graph determines the correct build and release order for interdependent projects. The logic is located in `pkg/depsgraph/builder.go`.\n\n*   **Stateful Workflow**: The release process is composed of three commands: `plan`, `tui`, and `apply`.\n    1.  `grove release plan`: Analyzes repositories for changes and generates a release plan file.\n    2.  `grove release tui`: Launches a terminal user interface to review, modify, and approve the generated plan.\n    3.  `grove release apply`: Executes the approved plan.\n    This separation allows a release to be reviewed or paused without losing its state.\n\n*   **Interactive TUI**: The `grove release tui` command provides an interface for managing the release plan. From the TUI, a user can review proposed version bumps, change the bump level (major, minor, patch), generate changelogs with LLM assistance, write changelogs to disk for final review, and approve each repository for release. This is implemented in `cmd/release_tui.go`.\n\n*   **Dependency Synchronization**: During the `apply` phase, `grove` processes repositories in the order determined by the dependency graph. After an upstream workspace is tagged and its release is published, the orchestrator executes commands (e.g., `go get`) in downstream workspaces to update their dependency files to the new version before they are subsequently tagged and released. This is handled by the `orchestrateRelease` function in `cmd/release.go`."
        }
      ]
    },
    "installation": {
      "title": "Installation",
      "content": "This guide provides instructions for installing the `grove` command-line interface and the tools in its ecosystem.",
      "subsections": [
        {
          "title": "Prerequisites",
          "content": "Before installing, ensure the following requirements are met:\n\n*   **Operating System**: macOS or Linux.\n*   **Architecture**: `amd64` (Intel) or `arm64` (Apple Silicon, ARM).\n*   **Dependencies**:\n    *   `git`: Required for version control and managing workspaces.\n    *   `curl`: Used by the installation script to download binaries.\n    *   `gh` (GitHub CLI): Used for private repositories. The installer will use it automatically if it is installed and authenticated."
        },
        {
          "title": "Installation Script",
          "content": "The primary installation method is a script that detects the operating system and architecture.\n\nRun the following command in a terminal:\n\n\nThe script performs the following steps:\n1.  Detects the operating system (macOS or Linux) and architecture (amd64 or arm64).\n2.  Checks for an authenticated GitHub CLI (`gh`). If found, it uses `gh` to download assets. Otherwise, it falls back to `curl`.\n3.  Fetches the latest release from the `mattsolo1/grove-meta` GitHub repository.\n4.  Downloads the appropriate binary for the system.\n5.  Installs the binary to `~/.grove/bin/grove` and makes it executable.",
          "code_blocks": [
            "curl -sSfL https://raw.githubusercontent.com/mattsolo1/grove-meta/main/scripts/install.sh | sh"
          ]
        },
        {
          "title": "Post-Installation Setup",
          "content": "After installation, add the Grove bin directory to the shell's `PATH` environment variable.\n\n#### 1. Configure PATH\n\nAdd the following line to the shell's configuration file (e.g., `~/.zshrc`, `~/.bashrc`, or `~/.profile`):\n\n\n#### 2. Apply Changes\n\nFor the changes to take effect, either restart the terminal or source the configuration file:\n\n\n#### 3. Verify Installation\n\nRun the `version` command to confirm that the `grove` CLI is installed and accessible:\n\n\nThis should display the version, commit, and build date of the `grove` binary.",
          "code_blocks": [
            "export PATH=\"$HOME/.grove/bin:$PATH\"",
            "# For Zsh\nsource ~/.zshrc\n\n# For Bash\nsource ~/.bashrc",
            "grove version"
          ]
        },
        {
          "title": "Installing Grove Tools",
          "content": "The `grove` CLI is used to install other tools from the ecosystem.\n\n#### Install All Tools\n\nTo install the latest stable versions of all available tools, run:\n\n\nFor private repositories, use the `--use-gh` flag to authenticate with the GitHub CLI:\n\n\n#### Install Specific Tools\n\nTools can be installed by name or alias.\n\n\n#### Install a Specific Version\n\nTo install a specific version of a tool, use the `@version` syntax.\n\n\n#### Install Nightly Builds\n\nDevelopment builds from the `main` branch can be installed using the `@nightly` tag.",
          "code_blocks": [
            "grove install all",
            "grove install all --use-gh",
            "# Install a single tool by its alias\ngrove install cx\n\n# Install multiple tools\ngrove install flow nb",
            "grove install cx@v0.2.1",
            "# Install the nightly build of a single tool\ngrove install cx@nightly\n\n# Install nightly builds of all tools\ngrove install all@nightly"
          ]
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`grove` is the CLI interface and package manager for the Grove ecosystem, providing a unified entry point for installing, managing, and orchestrating a suite of specialized tools.\n\n\u003c!-- placeholder for animated gif --\u003e\n\n### Key Features\n\n*   **Unified Command Interface**: Acts as a command delegator. Running `grove cx stats` finds and executes the `cx` binary with the `stats` argument, providing a single entry point for all tools.\n*   **Tool Management**: Manages the lifecycle of Grove tools through `install`, `update`, and `version` commands. It resolves inter-tool dependencies, downloads official releases, and can build and install from the main branch.\n*   **Local Development Support**: The `grove dev` command suite registers and switches between multiple local builds of any tool, allowing different versions from separate worktrees to be tested across the system.\n*   **Ecosystem Orchestration**: Contains commands that operate across all projects in an ecosystem, including a parallel build system (`grove build`), a command runner (`grove run`), and a dependency-aware, stateful release engine (`grove release`)."
    }
  }
}
{
  "core_concepts": [
    {
      "name": "Command Delegation",
      "description": "The core of this pattern is command delegation. When you run a command like `grove cx stats`, `grove` doesn't know what `stats` means. It recognizes `cx` as an alias for an installed tool (`grove-context`) and forwards the entire command (`cx stats`) to that tool's binary.\n\nThis logic is primarily handled in `cmd/root.go`, where the `delegateToTool` function resolves the tool name to a binary path and executes it.\n\n**Execution Flow:**\n1.  User runs `grove \u003ctool-alias\u003e [args...]`.\n2.  `grove` checks if `\u003ctool-alias\u003e` is one of its own built-in commands (e.g., `install`, `list`, `dev`).\n3.  If not, it assumes `\u003ctool-alias\u003e` is an external tool.\n4.  It searches for the corresponding binary, prioritizing workspace-specific versions (see below).\n5.  It executes the found binary, passing along all subsequent arguments.",
      "example": "# This command...\ngrove cx stats --json\n\n# ...is effectively translated by grove into executing:\n/path/to/cx stats --json"
    },
    {
      "name": "Package Management",
      "description": "As a package manager, `grove` handles the lifecycle of other tools. The `install`, `update`, and `version` commands manage fetching release assets from GitHub, placing them in a versioned directory structure, and managing symlinks for activation.\n\n---\n\n## 2. Workspaces and Ecosystems\n\nGrove provides robust support for managing projects, whether they are standalone repositories or part of a larger monorepo (an \"ecosystem\").",
      "example": ""
    },
    {
      "name": "Definitions",
      "description": "-   **Workspace**: A directory that represents a single project or tool. A workspace is identified by the presence of a `grove.yml` file. Most Grove tools are designed to be run from within a workspace.\n-   **Ecosystem**: A top-level directory (typically a monorepo) that contains multiple workspaces. An ecosystem is defined by a root `grove.yml` file that specifies which subdirectories are considered workspaces, often using glob patterns (e.g., `workspaces: [\"*\"]`).\n-   **Development Workspace**: A temporary, isolated workspace, usually created from a Git worktree, for developing features. It is identified by a `.grove-workspace` marker file.",
      "example": ""
    },
    {
      "name": "Context-Aware Binary Delegation",
      "description": "One of Grove's key features is its ability to automatically use the correct version of a tool based on your current location.\n\n-   **Inside a Development Workspace**: If you are inside a directory containing a `.grove-workspace` file, `grove` will automatically prioritize and execute binaries found within that workspace (e.g., in a local `./bin` directory). This allows developers to build a tool from source and have it used immediately without any manual linking. This is achieved by dynamically prepending the workspace's binary directories to the `PATH` for the delegated command, as seen in `cmd/root.go`.\n\n-   **Outside a Workspace**: When run outside a workspace, `grove` delegates to the globally managed binaries located in `~/.grove/bin`.\n\nThe `grove dev workspace` command can be used to inspect the current workspace context.\n\n---\n\n## 3. Binary and Version Management\n\n`grove` manages two distinct types of tool binaries: released versions and local development versions. This system provides a clear separation between stable, installed tools and local builds used for development.",
      "example": ""
    },
    {
      "name": "Directory Structure",
      "description": "All globally managed tools are stored within the `~/.grove` directory:",
      "example": "~/.grove/\n├── bin/              # Symlinks to active tool binaries\n├── versions/         # Stores downloaded release binaries\n│   ├── v0.1.0/\n│   │   └── bin/\n│   │       ├── cx\n│   │       └── flow\n│   └── v0.2.0/\n│       └── bin/\n│           └── grove\n├── devlinks.json     # Registry for local development binaries\n└── active_versions.json # Maps each tool to its active released version"
    },
    {
      "name": "Released Binaries",
      "description": "-   **Installation**: `grove install \u003ctool\u003e` downloads a specific version from a GitHub release and places it in `~/.grove/versions/\u003cversion\u003e/bin/`.\n-   **Activation**: `grove version use \u003ctool@version\u003e` updates `active_versions.json` and uses the \"reconciler\" to create a symlink from `~/.grove/bin/\u003ctool\u003e` to the binary in the `versions` directory.",
      "example": ""
    },
    {
      "name": "Development Binaries",
      "description": "-   **Linking**: `grove dev link \u003cpath\u003e` registers a locally built binary. It records the path to the binary in `devlinks.json` but does not move it.\n-   **Activation**: `grove dev use \u003ctool\u003e \u003calias\u003e` creates a symlink in `~/.grove/bin/\u003ctool\u003e` that points directly to the locally built binary.",
      "example": ""
    },
    {
      "name": "The Reconciler Pattern",
      "description": "The **reconciler** (`pkg/reconciler/reconciler.go`) is responsible for managing this layered system. It determines the \"effective source\" for any given tool with the following precedence:\n\n1.  **Workspace Binary** (Highest): If inside a workspace, use the binary from that workspace's `bin/` directory. (Handled by the delegator).\n2.  **Active Development Link**: If a dev link is active for the tool (`grove dev use`), its symlink in `~/.grove/bin` points to the local build.\n3.  **Active Released Version** (Lowest): Otherwise, the symlink in `~/.grove/bin` points to the tool's active version in `~/.grove/versions/`.\n\nThis ensures that development work is always prioritized but falls back predictably to stable, released versions.\n\n---\n\n## 4. Tool Registry and Discovery\n\nTool discovery is managed through a combination of a static internal registry and dynamic workspace discovery.\n\n-   **Internal Registry**: A hardcoded map in `pkg/sdk/manager.go` associates tool aliases (e.g., `cx`) with their corresponding GitHub repository names (`grove-context`). This registry is the source of truth for `grove install` and `grove list`.\n-   **Workspace Discovery**: Commands like `grove run` and `grove workspace status` dynamically discover workspaces by parsing the `workspaces` field in the root `grove.yml` file, as implemented in `pkg/workspace/discover.go`.\n\n---\n\n## 5. Dependency Management and Release Orchestration\n\nFor monorepo (\"ecosystem\") development, `grove` provides tools to manage dependencies and orchestrate complex, multi-repository releases.\n\n-   **Dependency Graph**: `grove` can build an internal dependency graph of all workspaces (`pkg/depsgraph/graph.go`). This is used to understand the relationships between tools. For example, it knows that `grove-context` depends on `grove-core`.\n-   **`grove deps`**: The `deps` command family allows for managing Go module dependencies across the entire ecosystem. `grove deps sync` is particularly useful, as it updates all internal Grove dependencies to their latest versions across all tools.\n-   **`grove release`**: This command orchestrates a full ecosystem release. It uses the dependency graph to perform a topological sort, ensuring that base libraries are released before the tools that depend on them. It automates version calculation, changelog generation (including an LLM-powered option), Git tagging, and monitoring of CI/CD release workflows. The `grove release --interactive` command provides a Terminal UI for planning and executing these complex releases.",
      "example": ""
    }
  ]
}
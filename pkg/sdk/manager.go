package sdk

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"

	"github.com/mattsolo1/grove-meta/pkg/devlinks"
	"github.com/mattsolo1/grove-meta/pkg/workspace"
)

const (
	// Directory structure constants
	GroveDir          = ".grove"
	VersionsDir       = "versions"
	BinDir            = "bin"
	ActiveVersionFile = "active_version"

	// GitHub API constants
	GitHubOwner = "mattsolo1"
	GitHubAPI   = "https://api.github.com"
)

// ToolInfo contains information about a tool
type ToolInfo struct {
	Alias        string   // Default alias and binary name
	Dependencies []string // List of canonical RepoNames this tool depends on
}

// toolRegistry is auto-generated by tools/registry-generator
// See pkg/sdk/registry_generated.go

// AliasConfig represents the structure of the aliases.json file
type AliasConfig struct {
	Aliases map[string]string `json:"aliases"` // repoName -> custom alias
}

// LoadAliases loads the user's custom alias configuration
func LoadAliases(groveHome string) (*AliasConfig, error) {
	aliasFile := filepath.Join(groveHome, "aliases.json")
	conf := &AliasConfig{Aliases: make(map[string]string)}

	if data, err := os.ReadFile(aliasFile); err == nil {
		if err := json.Unmarshal(data, &conf); err != nil {
			// If parsing fails, proceed with an empty config
			conf = &AliasConfig{Aliases: make(map[string]string)}
		}
	}
	return conf, nil
}

// SaveAliases saves the user's custom alias configuration
func SaveAliases(groveHome string, config *AliasConfig) error {
	aliasFile := filepath.Join(groveHome, "aliases.json")
	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal aliases: %w", err)
	}
	return os.WriteFile(aliasFile, data, 0644)
}

// FindTool resolves a user-provided identifier (repo name, alias) to its canonical info
// It returns the canonical repoName, the ToolInfo, the effective alias, and a found boolean
func FindTool(identifier string) (string, ToolInfo, string, bool) {
	groveHome := filepath.Join(os.Getenv("HOME"), ".grove")
	aliases, _ := LoadAliases(groveHome)

	// 1. Check if identifier is a custom alias
	for repoName, customAlias := range aliases.Aliases {
		if identifier == customAlias {
			if info, ok := toolRegistry[repoName]; ok {
				return repoName, info, customAlias, true
			}
		}
	}

	// 2. Check if identifier is a default alias or a repo name
	for repoName, info := range toolRegistry {
		if identifier == info.Alias || identifier == repoName {
			effectiveAlias := info.Alias
			if customAlias, ok := aliases.Aliases[repoName]; ok {
				effectiveAlias = customAlias
			}
			return repoName, info, effectiveAlias, true
		}
	}

	return "", ToolInfo{}, "", false
}

// GetAllTools returns all registered tool repository names
func GetAllTools() []string {
	tools := make([]string, 0, len(toolRegistry))
	for repoName := range toolRegistry {
		tools = append(tools, repoName)
	}
	sort.Strings(tools)
	return tools
}

// GetToolRegistry returns the tool registry map
func GetToolRegistry() map[string]ToolInfo {
	return toolRegistry
}

// Manager handles SDK installation and version management
type Manager struct {
	homeDir string
	baseDir string
	useGH   bool
}

// NewManager creates a new SDK manager instance
func NewManager() (*Manager, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	baseDir := filepath.Join(homeDir, GroveDir)

	// Run migration on initialization
	if err := MigrateFromSingleVersion(baseDir); err != nil {
		// Ignore migration errors - it's a one-time operation
	}

	return &Manager{
		homeDir: homeDir,
		baseDir: baseDir,
		useGH:   false,
	}, nil
}

// SetUseGH sets whether to use gh CLI for downloads
func (m *Manager) SetUseGH(useGH bool) {
	m.useGH = useGH
}

// ResolveDependencies takes a list of user-specified tools and returns a complete
// list of tools to install, including all dependencies
func (m *Manager) ResolveDependencies(initialToolSpecs []string) ([]string, error) {
	toProcess := make(map[string]string) // repoName -> version
	final := make(map[string]string)

	// 1. Initial population from user input
	for _, spec := range initialToolSpecs {
		parts := strings.SplitN(spec, "@", 2)
		identifier := parts[0]
		version := "latest"
		if len(parts) > 1 {
			version = parts[1]
		}

		repoName, _, _, found := FindTool(identifier)
		if !found {
			return nil, fmt.Errorf("tool '%s' not found in registry", identifier)
		}
		toProcess[repoName] = version
	}

	// 2. Breadth-first traversal to find all dependencies
	queue := make([]string, 0, len(toProcess))
	for repoName := range toProcess {
		queue = append(queue, repoName)
		final[repoName] = toProcess[repoName]
	}

	for len(queue) > 0 {
		currentRepo := queue[0]
		queue = queue[1:]

		_, info, _, found := FindTool(currentRepo)
		if !found || len(info.Dependencies) == 0 {
			continue
		}

		for _, depRepoName := range info.Dependencies {
			if _, exists := final[depRepoName]; !exists {
				final[depRepoName] = "latest" // Dependencies default to latest
				queue = append(queue, depRepoName)
			}
		}
	}

	// 3. Format the final list as specs
	result := make([]string, 0, len(final))
	for repoName, version := range final {
		if version == "latest" {
			result = append(result, repoName)
		} else {
			result = append(result, fmt.Sprintf("%s@%s", repoName, version))
		}
	}
	sort.Strings(result)
	return result, nil
}

// EnsureDirs creates the necessary directory structure
func (m *Manager) EnsureDirs() error {
	dirs := []string{
		m.baseDir,
		filepath.Join(m.baseDir, BinDir),
		filepath.Join(m.baseDir, VersionsDir),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// GetActiveVersion returns the currently active version (DEPRECATED)
// This method is kept for backward compatibility but should not be used
func (m *Manager) GetActiveVersion() (string, error) {
	// Try to migrate from old format if needed
	if err := MigrateFromSingleVersion(m.baseDir); err != nil {
		// Ignore migration errors
	}

	// Return empty string as there's no single active version anymore
	return "", fmt.Errorf("no single active version - use GetToolVersion instead")
}

// GetToolVersion returns the active version for a specific tool
func (m *Manager) GetToolVersion(tool string) (string, error) {
	// Get canonical repo name
	repoName, _, _, found := FindTool(tool)
	if !found {
		// If not found, use the tool name as is (backward compatibility)
		repoName = tool
	}

	tv, err := LoadToolVersions(m.baseDir)
	if err != nil {
		return "", fmt.Errorf("failed to load tool versions: %w", err)
	}

	version := tv.GetToolVersion(repoName)
	if version == "" {
		return "", fmt.Errorf("no active version for %s", repoName)
	}

	return version, nil
}

// SetActiveVersion sets the active version (DEPRECATED)
// This method is kept for backward compatibility but should not be used
func (m *Manager) SetActiveVersion(version string) error {
	return fmt.Errorf("SetActiveVersion is deprecated - use SetToolVersion instead")
}

// SetToolVersion sets the active version for a specific tool
func (m *Manager) SetToolVersion(tool, version string) error {
	// Get canonical repo name
	repoName, _, _, found := FindTool(tool)
	if !found {
		// If not found, use the tool name as is (backward compatibility)
		repoName = tool
	}

	tv, err := LoadToolVersions(m.baseDir)
	if err != nil {
		return fmt.Errorf("failed to load tool versions: %w", err)
	}

	tv.SetToolVersion(repoName, version)

	if err := tv.Save(m.baseDir); err != nil {
		return fmt.Errorf("failed to save tool versions: %w", err)
	}

	return nil
}

// GitHubRelease represents a GitHub release
type GitHubRelease struct {
	TagName    string `json:"tag_name"`
	Prerelease bool   `json:"prerelease"`
	Assets     []struct {
		Name               string `json:"name"`
		BrowserDownloadURL string `json:"browser_download_url"`
	} `json:"assets"`
}

// resolveRepoName resolves a tool name to its repository name
// It uses the FindTool function to handle aliases and canonical names
func resolveRepoName(toolName string) (string, error) {
	repoName, _, _, found := FindTool(toolName)
	if found {
		return repoName, nil
	}

	// If not found, check if it's already a grove- repository name
	// This allows for future tools not yet in the registry
	if strings.HasPrefix(toolName, "grove-") {
		return toolName, nil
	}

	return "", fmt.Errorf("unknown tool: %s", toolName)
}

// GetLatestVersionTag fetches the latest release tag from GitHub for a specific tool
func (m *Manager) GetLatestVersionTag(toolName string) (string, error) {
	repoName, err := resolveRepoName(toolName)
	if err != nil {
		return "", err
	}

	if m.useGH {
		return m.getLatestVersionTagWithGH(repoName)
	}

	url := fmt.Sprintf("%s/repos/%s/%s/releases/latest", GitHubAPI, GitHubOwner, repoName)

	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to fetch latest release: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("GitHub API returned status %d", resp.StatusCode)
	}

	var release GitHubRelease
	if err := json.NewDecoder(resp.Body).Decode(&release); err != nil {
		return "", fmt.Errorf("failed to decode release data: %w", err)
	}

	return release.TagName, nil
}

// getLatestVersionTagWithGH fetches the latest release tag using gh CLI
func (m *Manager) getLatestVersionTagWithGH(repoName string) (string, error) {
	cmd := exec.Command("gh", "release", "view", "--repo", fmt.Sprintf("%s/%s", GitHubOwner, repoName), "--json", "tagName")

	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("gh CLI failed to get latest release: %w", err)
	}

	var result struct {
		TagName string `json:"tagName"`
	}

	if err := json.Unmarshal(output, &result); err != nil {
		return "", fmt.Errorf("failed to parse gh output: %w", err)
	}

	return result.TagName, nil
}

// GetLatestPrereleaseVersionTag fetches the latest pre-release (RC/nightly) tag from GitHub
func (m *Manager) GetLatestPrereleaseVersionTag(toolName string) (string, error) {
	repoName, err := resolveRepoName(toolName)
	if err != nil {
		return "", err
	}

	if m.useGH {
		// Use gh CLI to list releases including pre-releases
		cmd := exec.Command("gh", "release", "list", "--repo", fmt.Sprintf("%s/%s", GitHubOwner, repoName), "--limit", "20", "--json", "tagName,isPrerelease")
		output, err := cmd.Output()
		if err != nil {
			return "", fmt.Errorf("gh CLI failed to list releases: %w", err)
		}

		var releases []struct {
			TagName      string `json:"tagName"`
			IsPrerelease bool   `json:"isPrerelease"`
		}

		if err := json.Unmarshal(output, &releases); err != nil {
			return "", fmt.Errorf("failed to parse gh output: %w", err)
		}

		// Find the first pre-release
		for _, release := range releases {
			if release.IsPrerelease {
				return release.TagName, nil
			}
		}

		return "", fmt.Errorf("no pre-release versions found for %s", toolName)
	}

	// Use GitHub API to list releases
	url := fmt.Sprintf("%s/repos/%s/%s/releases", GitHubAPI, GitHubOwner, repoName)

	resp, err := http.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to fetch releases: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("GitHub API returned status %d", resp.StatusCode)
	}

	var releases []GitHubRelease
	if err := json.NewDecoder(resp.Body).Decode(&releases); err != nil {
		return "", fmt.Errorf("failed to decode releases data: %w", err)
	}

	// Find the first pre-release
	for _, release := range releases {
		if release.Prerelease {
			return release.TagName, nil
		}
	}

	return "", fmt.Errorf("no pre-release versions found for %s", toolName)
}

// GetRelease fetches release information for a specific tool and version
func (m *Manager) GetRelease(toolName, version string) (*GitHubRelease, error) {
	repoName, err := resolveRepoName(toolName)
	if err != nil {
		return nil, err
	}

	if m.useGH {
		return m.getReleaseWithGH(repoName, version)
	}

	url := fmt.Sprintf("%s/repos/%s/%s/releases/tags/%s", GitHubAPI, GitHubOwner, repoName, version)

	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch release %s: %w", version, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API returned status %d for version %s", resp.StatusCode, version)
	}

	var release GitHubRelease
	if err := json.NewDecoder(resp.Body).Decode(&release); err != nil {
		return nil, fmt.Errorf("failed to decode release data: %w", err)
	}

	return &release, nil
}

// getReleaseWithGH fetches release information using gh CLI
func (m *Manager) getReleaseWithGH(repoName, version string) (*GitHubRelease, error) {
	cmd := exec.Command("gh", "release", "view", version, "--repo", fmt.Sprintf("%s/%s", GitHubOwner, repoName), "--json", "tagName,assets")

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("gh CLI failed to get release %s: %w", version, err)
	}

	var ghRelease struct {
		TagName string `json:"tagName"`
		Assets  []struct {
			Name string `json:"name"`
			URL  string `json:"url"`
		} `json:"assets"`
	}

	if err := json.Unmarshal(output, &ghRelease); err != nil {
		return nil, fmt.Errorf("failed to parse gh output: %w", err)
	}

	// Convert to GitHubRelease format
	release := &GitHubRelease{
		TagName: ghRelease.TagName,
	}

	for _, asset := range ghRelease.Assets {
		// Convert gh CLI URL format to browser download URL format
		release.Assets = append(release.Assets, struct {
			Name               string `json:"name"`
			BrowserDownloadURL string `json:"browser_download_url"`
		}{
			Name:               asset.Name,
			BrowserDownloadURL: fmt.Sprintf("https://github.com/%s/%s/releases/download/%s/%s", GitHubOwner, repoName, version, asset.Name),
		})
	}

	return release, nil
}

// ListInstalledVersions returns all installed versions
func (m *Manager) ListInstalledVersions() ([]string, error) {
	versionsDir := filepath.Join(m.baseDir, VersionsDir)
	entries, err := os.ReadDir(versionsDir)
	if err != nil {
		if os.IsNotExist(err) {
			return []string{}, nil
		}
		return nil, fmt.Errorf("failed to read versions directory: %w", err)
	}

	var versions []string
	for _, entry := range entries {
		if entry.IsDir() && strings.HasPrefix(entry.Name(), "v") {
			versions = append(versions, entry.Name())
		}
	}

	return versions, nil
}

// InstallTool installs a specific tool at a specific version
func (m *Manager) InstallTool(toolName, versionTag string) error {
	// Ensure directories exist
	if err := m.EnsureDirs(); err != nil {
		return err
	}

	// Get tool info using FindTool
	repoName, toolInfo, effectiveAlias, found := FindTool(toolName)
	if !found {
		return fmt.Errorf("unknown tool: %s", toolName)
	}

	// Get release information
	release, err := m.GetRelease(repoName, versionTag)
	if err != nil {
		return err
	}

	// Construct the binary name using the tool's default alias (not custom alias)
	osName := runtime.GOOS
	archName := runtime.GOARCH
	binaryAssetName := fmt.Sprintf("%s-%s-%s", toolInfo.Alias, osName, archName)

	// Find the asset URL
	var downloadURL string
	for _, asset := range release.Assets {
		if asset.Name == binaryAssetName {
			downloadURL = asset.BrowserDownloadURL
			break
		}
	}

	if downloadURL == "" {
		return fmt.Errorf("no binary found for %s on %s/%s", toolName, osName, archName)
	}

	// Create version directory
	versionBinDir := filepath.Join(m.baseDir, VersionsDir, versionTag, BinDir)
	if err := os.MkdirAll(versionBinDir, 0755); err != nil {
		return fmt.Errorf("failed to create version directory: %w", err)
	}

	// Download the binary - use effective alias as the binary name
	targetPath := filepath.Join(versionBinDir, effectiveAlias)
	if err := m.downloadFile(downloadURL, targetPath); err != nil {
		return fmt.Errorf("failed to download %s: %w", repoName, err)
	}

	// Make executable
	if err := os.Chmod(targetPath, 0755); err != nil {
		return fmt.Errorf("failed to make %s executable: %w", effectiveAlias, err)
	}

	return nil
}

// InstallAllToolsFromSource clones all Grove tools and builds them in a shared workspace
func (m *Manager) InstallAllToolsFromSource() error {
	// Ensure directories exist
	if err := m.EnsureDirs(); err != nil {
		return err
	}

	// Use a persistent workspace directory
	workspaceDir := filepath.Join(m.baseDir, "source-workspace")
	if err := os.MkdirAll(workspaceDir, 0755); err != nil {
		return fmt.Errorf("failed to create workspace directory: %w", err)
	}

	// Get all tools
	allTools := GetAllTools()

	// Collect all unique repos (tools + their dependencies)
	allRepos := make(map[string]ToolInfo)
	for _, toolName := range allTools {
		repoName, toolInfo, _, found := FindTool(toolName)
		if found {
			allRepos[repoName] = toolInfo
			// Add dependencies
			for _, dep := range toolInfo.Dependencies {
				depRepoName, depInfo, _, depFound := FindTool(dep)
				if depFound {
					allRepos[depRepoName] = depInfo
				}
			}
		}
	}

	fmt.Printf("Cloning %d repositories into workspace: %s\n", len(allRepos), workspaceDir)

	// Clone all repos
	for repo := range allRepos {
		repoPath := filepath.Join(workspaceDir, repo)

		// Check if already cloned
		if _, err := os.Stat(repoPath); err == nil {
			fmt.Printf("  Updating %s...\n", repo)
			pullCmd := exec.Command("git", "-C", repoPath, "pull", "--ff-only")
			if err := pullCmd.Run(); err != nil {
				// If pull fails, remove and re-clone
				os.RemoveAll(repoPath)
			} else {
				continue
			}
		}

		fmt.Printf("  Cloning %s...\n", repo)
		repoSlug := fmt.Sprintf("%s/%s", GitHubOwner, repo)
		cloneCmd := exec.Command("gh", "repo", "clone", repoSlug, repoPath, "--", "--depth=1")
		if output, err := cloneCmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to clone %s: %w\nOutput: %s", repo, err, string(output))
		}
	}

	// Create go.work file (only include repos with go.mod)
	fmt.Println("\nCreating Go workspace...")
	goWorkPath := filepath.Join(workspaceDir, "go.work")
	var workContent strings.Builder
	workContent.WriteString("go 1.24.4\n\n")
	workContent.WriteString("use (\n")
	for repo := range allRepos {
		// Check if repo has a go.mod file
		goModPath := filepath.Join(workspaceDir, repo, "go.mod")
		if _, err := os.Stat(goModPath); err == nil {
			workContent.WriteString(fmt.Sprintf("\t./%s\n", repo))
		}
	}
	workContent.WriteString(")\n\n")
	workContent.WriteString("replace github.com/fsnotify/fsevents => ./grove-proxy/internal/fsevents-stub\n")

	if err := os.WriteFile(goWorkPath, []byte(workContent.String()), 0644); err != nil {
		return fmt.Errorf("failed to create go.work: %w", err)
	}

	// Build each tool
	fmt.Println("\nBuilding tools...")
	for _, toolName := range allTools {
		repoName, _, effectiveAlias, found := FindTool(toolName)
		if !found {
			continue
		}

		buildDir := filepath.Join(workspaceDir, repoName)

		// Check if repo has binaries defined in grove.yml
		binaries, err := workspace.DiscoverLocalBinaries(buildDir)
		if err != nil {
			// Skip repos that don't produce binaries (like grove-core)
			fmt.Printf("  ⊘ %s skipped (not a binary tool)\n", toolName)
			continue
		}

		fmt.Printf("  Building %s...\n", toolName)

		// Build with workspace
		buildCmd := exec.Command("make", "build")
		buildCmd.Dir = buildDir
		buildCmd.Env = append(os.Environ(),
			"GOPRIVATE=github.com/mattsolo1/*",
			fmt.Sprintf("GOWORK=%s", goWorkPath))

		if output, err := buildCmd.CombinedOutput(); err != nil {
			return fmt.Errorf("build failed for %s: %w\nOutput: %s", toolName, err, string(output))
		}

		// Get commit SHA for version tag
		shaCmd := exec.Command("git", "-C", buildDir, "rev-parse", "--short", "HEAD")
		shaOutput, err := shaCmd.Output()
		if err != nil {
			return fmt.Errorf("failed to get commit SHA for %s: %w", toolName, err)
		}
		sha := strings.TrimSpace(string(shaOutput))
		versionTag := fmt.Sprintf("source-%s", sha)

		// Use the first binary found (most repos have only one)
		if len(binaries) == 0 {
			return fmt.Errorf("no binaries found for %s", toolName)
		}

		binaryPath := binaries[0].Path

		// Install binary
		versionBinDir := filepath.Join(m.baseDir, VersionsDir, versionTag, BinDir)
		if err := os.MkdirAll(versionBinDir, 0755); err != nil {
			return fmt.Errorf("failed to create version directory: %w", err)
		}

		targetPath := filepath.Join(versionBinDir, effectiveAlias)
		sourceFile, err := os.Open(binaryPath)
		if err != nil {
			return fmt.Errorf("failed to open built binary: %w", err)
		}
		defer sourceFile.Close()

		destFile, err := os.Create(targetPath)
		if err != nil {
			return fmt.Errorf("failed to create target binary: %w", err)
		}
		defer destFile.Close()

		if _, err := io.Copy(destFile, sourceFile); err != nil {
			return fmt.Errorf("failed to copy binary: %w", err)
		}

		if err := os.Chmod(targetPath, 0755); err != nil {
			return fmt.Errorf("failed to make %s executable: %w", effectiveAlias, err)
		}

		// Activate this version
		if err := m.UseToolVersion(toolName, versionTag); err != nil {
			return fmt.Errorf("failed to activate %s: %w", toolName, err)
		}

		// Run `grove dev cwd` in the build directory
		devCmd := exec.Command("grove", "dev", "cwd")
		devCmd.Dir = buildDir
		if output, err := devCmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to run 'grove dev cwd' for %s: %w\nOutput: %s", toolName, err, string(output))
		}

		fmt.Printf("    ✓ %s installed as %s\n", toolName, versionTag)
	}

	return nil
}

// InstallToolFromSource clones and builds a tool from its main branch using a Go workspace
func (m *Manager) InstallToolFromSource(toolName string) (string, error) {
	// Ensure directories exist
	if err := m.EnsureDirs(); err != nil {
		return "", err
	}

	// Get tool info using FindTool
	repoName, toolInfo, effectiveAlias, found := FindTool(toolName)
	if !found {
		return "", fmt.Errorf("unknown tool: %s", toolName)
	}

	// Use a persistent workspace directory in ~/.grove/source-workspace
	workspaceDir := filepath.Join(m.baseDir, "source-workspace")
	if err := os.MkdirAll(workspaceDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create workspace directory: %w", err)
	}

	// Collect all repos we need to clone (tool + its dependencies)
	reposToClone := make(map[string]bool)
	reposToClone[repoName] = true

	// Add dependencies
	for _, dep := range toolInfo.Dependencies {
		depRepoName, _, _, found := FindTool(dep)
		if found {
			reposToClone[depRepoName] = true
		}
	}

	// Clone all required repos
	for repo := range reposToClone {
		repoPath := filepath.Join(workspaceDir, repo)

		// Check if already cloned, if so pull latest
		if _, err := os.Stat(repoPath); err == nil {
			// Already exists, pull latest
			pullCmd := exec.Command("git", "-C", repoPath, "pull", "--ff-only")
			if err := pullCmd.Run(); err != nil {
				// If pull fails, remove and re-clone
				os.RemoveAll(repoPath)
			} else {
				continue // Successfully pulled
			}
		}

		// Clone the repository
		repoSlug := fmt.Sprintf("%s/%s", GitHubOwner, repo)
		cloneCmd := exec.Command("gh", "repo", "clone", repoSlug, repoPath, "--", "--depth=1")
		if output, err := cloneCmd.CombinedOutput(); err != nil {
			return "", fmt.Errorf("failed to clone %s: %w\nOutput: %s", repo, err, string(output))
		}
	}

	// Create go.work file with correct version
	goWorkPath := filepath.Join(workspaceDir, "go.work")
	var workContent strings.Builder
	workContent.WriteString("go 1.24.4\n\n")
	workContent.WriteString("use (\n")
	for repo := range reposToClone {
		workContent.WriteString(fmt.Sprintf("\t./%s\n", repo))
	}
	workContent.WriteString(")\n")

	if err := os.WriteFile(goWorkPath, []byte(workContent.String()), 0644); err != nil {
		return "", fmt.Errorf("failed to create go.work: %w", err)
	}

	// Build in the workspace context
	buildDir := filepath.Join(workspaceDir, repoName)

	// Get the short commit SHA from the main tool repo
	shaCmd := exec.Command("git", "-C", buildDir, "rev-parse", "--short", "HEAD")
	shaOutput, err := shaCmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to get commit SHA: %w", err)
	}
	sha := strings.TrimSpace(string(shaOutput))
	versionTag := fmt.Sprintf("source-%s", sha)

	// Build the binary using make with workspace
	buildCmd := exec.Command("make", "build")
	buildCmd.Dir = buildDir
	buildCmd.Env = append(os.Environ(),
		"GOPRIVATE=github.com/mattsolo1/*",
		fmt.Sprintf("GOWORK=%s", goWorkPath))
	if output, err := buildCmd.CombinedOutput(); err != nil {
		return "", fmt.Errorf("build failed: %w\nOutput: %s", err, string(output))
	}

	// Discover the built binary using workspace package
	binaries, err := workspace.DiscoverLocalBinaries(buildDir)
	if err != nil {
		return "", fmt.Errorf("failed to discover built binary: %w", err)
	}

	// Find the binary for this specific tool
	var binaryPath string
	for _, binary := range binaries {
		if binary.Name == effectiveAlias {
			binaryPath = binary.Path
			break
		}
	}

	if binaryPath == "" {
		return "", fmt.Errorf("could not find built binary for %s", effectiveAlias)
	}

	// Create version directory
	versionBinDir := filepath.Join(m.baseDir, VersionsDir, versionTag, BinDir)
	if err := os.MkdirAll(versionBinDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create version directory: %w", err)
	}

	// Copy the binary to the version directory - use effective alias
	targetPath := filepath.Join(versionBinDir, effectiveAlias)
	sourceFile, err := os.Open(binaryPath)
	if err != nil {
		return "", fmt.Errorf("failed to open built binary: %w", err)
	}
	defer sourceFile.Close()

	destFile, err := os.Create(targetPath)
	if err != nil {
		return "", fmt.Errorf("failed to create target binary: %w", err)
	}
	defer destFile.Close()

	if _, err := io.Copy(destFile, sourceFile); err != nil {
		return "", fmt.Errorf("failed to copy binary: %w", err)
	}

	// Make executable
	if err := os.Chmod(targetPath, 0755); err != nil {
		return "", fmt.Errorf("failed to make %s executable: %w", effectiveAlias, err)
	}

	return versionTag, nil
}

// UseVersion switches to a specific version (DEPRECATED)
func (m *Manager) UseVersion(versionTag string) error {
	return fmt.Errorf("UseVersion is deprecated - use UseToolVersion instead")
}

// UseToolVersion switches a specific tool to a specific version
func (m *Manager) UseToolVersion(tool, versionTag string) error {
	// Get tool info using FindTool
	repoName, _, effectiveAlias, found := FindTool(tool)
	if !found {
		// If not found, use the tool name as is (backward compatibility)
		repoName = tool
		effectiveAlias = tool
	}

	// Check if the tool at this version is installed
	toolPath := filepath.Join(m.baseDir, VersionsDir, versionTag, BinDir, effectiveAlias)
	if _, err := os.Stat(toolPath); os.IsNotExist(err) {
		return fmt.Errorf("tool %s version %s is not installed", repoName, versionTag)
	}

	// Update the tool version - use repoName as the key
	if err := m.SetToolVersion(repoName, versionTag); err != nil {
		return err
	}

	// The caller should handle symlinking via reconciler
	// This avoids circular dependencies

	return nil
}

// UninstallVersion removes a specific version
func (m *Manager) UninstallVersion(versionTag string) error {
	// Check if it's the active version
	activeVersion, err := m.GetActiveVersion()
	if err != nil {
		return err
	}

	if activeVersion == versionTag {
		// Clear active version and symlinks
		if err := m.SetActiveVersion(""); err != nil {
			return err
		}

		// Clear symlinks
		binDir := filepath.Join(m.baseDir, BinDir)
		entries, _ := os.ReadDir(binDir)
		for _, entry := range entries {
			if !entry.IsDir() {
				path := filepath.Join(binDir, entry.Name())
				if info, err := os.Lstat(path); err == nil && info.Mode()&os.ModeSymlink != 0 {
					os.Remove(path)
				}
			}
		}
	}

	// Remove version directory
	versionDir := filepath.Join(m.baseDir, VersionsDir, versionTag)
	return os.RemoveAll(versionDir)
}

// downloadFile downloads a file from a URL
func (m *Manager) downloadFile(url, targetPath string) error {
	if m.useGH {
		return m.downloadFileWithGH(url, targetPath)
	}

	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("download failed with status %d", resp.StatusCode)
	}

	out, err := os.Create(targetPath)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}

// downloadFileWithGH downloads a file using gh CLI (supports private repos)
func (m *Manager) downloadFileWithGH(url, targetPath string) error {
	// Extract owner, repo, tag, and asset name from the URL
	// URL format: https://github.com/{owner}/{repo}/releases/download/{tag}/{asset}
	parts := strings.Split(url, "/")
	if len(parts) < 8 || parts[2] != "github.com" || parts[5] != "releases" || parts[6] != "download" {
		return fmt.Errorf("invalid GitHub release URL format: %s", url)
	}

	owner := parts[3]
	repo := parts[4]
	tag := parts[7]
	asset := parts[8]

	// Use gh CLI to download the release asset
	cmd := exec.Command("gh", "release", "download", tag, "--repo", fmt.Sprintf("%s/%s", owner, repo), "--pattern", asset, "--dir", filepath.Dir(targetPath))

	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("gh CLI download failed: %w\nOutput: %s", err, string(output))
	}

	// gh downloads with the original filename, so we may need to rename
	downloadedPath := filepath.Join(filepath.Dir(targetPath), asset)
	if downloadedPath != targetPath {
		if err := os.Rename(downloadedPath, targetPath); err != nil {
			return fmt.Errorf("failed to rename downloaded file: %w", err)
		}
	}

	return nil
}

// resetDevLinks clears all active development links
func (m *Manager) resetDevLinks() error {
	return devlinks.ClearAllCurrentLinks()
}

// GetToolToRepoMap returns the alias to repository name mapping
func GetToolToRepoMap() map[string]string {
	// Return a copy to prevent external modification
	result := make(map[string]string, len(toolRegistry))
	for repoName, info := range toolRegistry {
		result[info.Alias] = repoName
	}
	return result
}
